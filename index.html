<!DOCTYPE html>
<html lang="zh-CN">
<head>
 <meta charset="UTF-8">
 <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
 <meta name="apple-mobile-web-app-capable" content="yes">
 <meta name="apple-mobile-web-app-title" content="å®‡ä¸œæŠ¥ä»·">
 <title>å®‡ä¸œçººç»‡æŠ¥ä»·ç³»ç»Ÿ V4.1 (æ™ºèƒ½äº‘ç«¯ç‰ˆ)</title>
 
 <script src="https://cdn.tailwindcss.com"></script>
 
 <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
 
 <link rel="stylesheet" href="https://unpkg.com/element-plus/dist/index.css">
 <script src="https://unpkg.com/element-plus"></script>
 
 <script src="https://unpkg.com/@element-plus/icons-vue"></script>
 
 <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
 <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
 <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
 
 <!-- PDF å¯¼å‡ºåº“ -->
 <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
 <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js"></script>
 
 <!-- æ–°å¢ html2canvas åº“ç”¨äºPDFå¯¼å‡º -->
 <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
 
 <!-- Google API å®¢æˆ·ç«¯åº“ -->
 <script src="https://apis.google.com/js/api.js"></script>
 
 <style>
 /* *********************************** */
 /* ***** ZA Bank é£æ ¼ UI æ ·å¼é‡æ„ ***** */
 /* *********************************** */
 [v-cloak] { display: none; }
 
 body {
 margin: 0;
 padding: 0;
 font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Microsoft YaHei";
 background-color: #f0f2f5; /* ZA Bank Soft Background */
 }
 
 /* --- Header & Main App --- */
 .app-header {
 background: linear-gradient(135deg, #52D1B2 0%, #40A891 100%); /* Soft ZA Green/Teal Gradient */
 color: white;
 box-shadow: 0 4px 12px rgba(0,0,0,0.1);
 border-bottom-left-radius: 20px;
 border-bottom-right-radius: 20px;
 }
 
 .stat-card {
 background: rgba(255, 255, 255, 0.9);
 backdrop-filter: blur(10px);
 border-radius: 16px; /* Big rounded corners */
 box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08), 0 1px 2px rgba(0, 0, 0, 0.05); /* Soft Neumorphism Shadow */
 }
 
 /* ç»Ÿè®¡å¡ç‰‡æ•°å­—é¢œè‰² */
 .stat-card .text-purple-600 {
     color: #667eea; /* ä¿æŒä¸€ä¸ªå¯è§çš„ Accent Color */
 }

 /* --- Product Card --- */
 .product-card {
 transition: all 0.3s ease;
 border: none; /* Remove harsh border */
 background-color: white;
 border-radius: 20px; /* Big rounded corners */
 box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05), 0 1px 4px rgba(0, 0, 0, 0.03); 
 }
 
 .product-card:hover {
 transform: translateY(-3px);
 box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1), 0 3px 6px rgba(0, 0, 0, 0.08); /* Lift effect */
 border: 1px solid #52D1B2; /* Subtle highlight border */
 }

 /* äº§å“å¡ç‰‡ä»·æ ¼åŒºåŸŸæ ·å¼è°ƒæ•´ */
 .product-card .bg-gradient-to-r {
    background: linear-gradient(90deg, #E0F7FA, #B2EBF2); /* Soft Blue/Green for Price */
 }
 
 .product-card .text-green-600 {
    color: #40A891; /* Soft ZA Green text color */
 }
 
 .product-card .bg-purple-50 {
    background-color: #ECEFF1; /* Soft gray for bottom info */
 }
 
 /* --- Search Badges (Color update) --- */
 .badge-exact {
 background: linear-gradient(135deg, #52D1B2, #40A891); /* ZA Green */
 }
 
 .badge-fuzzy {
 background: linear-gradient(135deg, #ffc700, #f59e0b); /* ZA Yellow */
 }
 
 .badge-range {
 background: linear-gradient(135deg, #3b82f6, #2563eb); /* Standard Blue */
 }
 
 .image-preview {
 cursor: pointer;
 transition: transform 0.2s;
 }
 
 .image-preview:hover {
 transform: scale(1.05);
 }
 
 /* --- Element Plus Overrides for ZA Style (Neumorphism & Rounding) --- */
 
 /* Tabs å®¹å™¨ */
 .el-tabs {
 border-radius: 20px !important;
 overflow: hidden; 
 border: none !important;
 box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
 }
 
 .el-tabs--border-card {
 background-color: white !important; 
 }
 
 /* Tab å¤´éƒ¨ */
 .el-tabs__header {
 background-color: #f0f2f5 !important; 
 border-radius: 20px 20px 0 0 !important;
 padding: 8px 16px;
 border-bottom: none !important;
 }
 
 .el-tabs__item {
 font-size: 16px;
 font-weight: 600;
 border-radius: 12px; /* Tab Item Rounded Corner */
 margin: 4px; 
 }
 
 /* Selected tab (ZA Green Accent) */
 .el-tabs__item.is-active {
 background: linear-gradient(135deg, #52D1B2 0%, #40A891 100%) !important;
 color: white !important;
 border-color: transparent !important;
 box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
 }
 
 /* Card å®¹å™¨ */
 .el-card {
 border-radius: 20px;
 border: none;
 box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
 }

 /* Button Styling */
 .el-button {
 border-radius: 12px;
 font-weight: 600;
 transition: all 0.2s ease;
 }
 
 .el-button--primary {
 background: linear-gradient(135deg, #52D1B2 0%, #40A891 100%); /* Primary: ZA Green */
 border: none;
 box-shadow: 0 4px 8px rgba(82, 209, 178, 0.4);
 }
 
 .el-button--primary:hover {
 transform: translateY(-1px);
 box-shadow: 0 6px 12px rgba(82, 209, 178, 0.5);
 }
 
 .el-button--success {
 background: linear-gradient(135deg, #42A5F5 0%, #1976D2 100%); /* Success: Soft Blue */
 border: none;
 box-shadow: 0 4px 8px rgba(66, 165, 245, 0.4);
 }
 
 .el-button--warning {
 background: linear-gradient(135deg, #ffc700 0%, #f59e0b 100%); /* Warning: ZA Yellow */
 border: none;
 box-shadow: 0 4px 8px rgba(255, 199, 0, 0.4);
 color: #333 !important;
 }
 
 @media (max-width: 768px) {
 .el-tabs__item {
 font-size: 14px;
 padding: 0 12px;
 }
 
 .stat-card {
 margin: 8px 0;
 }
 }
 
 .fuzzy-match-btn {
 transition: all 0.2s ease;
 border-radius: 10px;
 }
 
 .fuzzy-match-btn:hover {
 transform: translateY(-2px);
 box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
 }
 
 .autocomplete-item {
 padding: 8px 12px;
 cursor: pointer;
 transition: background 0.2s;
 }
 
 .autocomplete-item:hover {
 background: #e0e0e0; /* Softer hover */
 }
 
 .el-drawer__body {
 padding: 20px;
 }
 
 /* ç§»åŠ¨ç«¯ä¼˜åŒ– */
 @media (max-width: 640px) {
 .app-header {
 padding: 12px;
 }
 
 .product-card {
 margin-bottom: 12px;
 }
 
 .el-card {
 margin-bottom: 12px;
 }

    /* ç»Ÿä¸€æŒ‰é’®ç»„å®¹å™¨æ ·å¼ */
    /* é‡‡ç”¨ Flex å‚ç›´å †å ï¼Œå¹¶ç¡®ä¿å†…éƒ¨æ‰€æœ‰å…ƒç´  W-FULLï¼Œå®ç°å®Œç¾å¯¹é½ */
    .mobile-btn-stack {
        display: flex;
        flex-direction: column; 
        gap: 10px; 
        /* ç¡®ä¿æŒ‰é’®ç»„å±…ä¸­ï¼Œ aunque æŒ‰é’®æœ¬èº«æ˜¯ w-full */
        align-items: center; 
    }

    /* å¯¼å…¥æŒ‰é’®ç»„å®¹å™¨ (å¢åŠ æ›´å¤§çš„é—´è·) */
    .mobile-btn-stack.import-group {
        gap: 24px;
    }
    
    /* ç¡®ä¿ç§»åŠ¨ç«¯æ‰€æœ‰æŒ‰é’®éƒ½æ˜¯å…¨å®½ */
    .el-button {
        width: 100% !important;
        margin-left: 0 !important; /* æ¸…é™¤ Element Plus é»˜è®¤çš„è¾¹è·ï¼Œç¡®ä¿å…¨å®½è®¡ç®—æ­£ç¡® */
        margin-right: 0 !important;
    }
    
    /* é’ˆå¯¹ el-tag åˆ é™¤æŒ‰é’®è¿›è¡Œæ ·å¼å¾®è°ƒï¼Œä½¿å…¶æ›´ç´§å‡‘ */
    .mobile-tag-delete {
        height: 28px;
        padding: 0 8px; /* å‡å°å†…è¾¹è· */
        line-height: 26px; /* è°ƒæ•´è¡Œé«˜ */
        font-size: 13px;
        font-weight: 600;
        cursor: pointer;
        /* ç§»é™¤ closable å±æ€§å¸¦æ¥çš„é»˜è®¤æ ·å¼ï¼Œä½¿ç”¨è‡ªå®šä¹‰çš„å›¾æ ‡ */
    }
 }

 /* PDF å¯¼å‡ºä¸“ç”¨æ ·å¼ï¼Œç¡®ä¿ä¸ä¼šæ±¡æŸ“æ­£å¸¸é¡µé¢ */
 #pdf-content {
    /* ä¸¥æ ¼æ§åˆ¶å®½åº¦ï¼Œç¬¦åˆA4æ‰“å°æ ‡å‡† (250mm æ˜¯ä¸€ä¸ªç›¸å¯¹å®‰å…¨çš„æ¯”ä¾‹) */
    width: 250mm; 
    padding: 15mm; 
    /* å…³é”®ä¿®å¤: ä½¿ç”¨ transform éšè—ï¼Œç¡®ä¿å°ºå¯¸è®¡ç®—æ­£ç¡® */
    position: absolute;
    left: 0;
    top: 0;
    transform: translate(-100%, 0); /* æ¨åˆ°å±å¹•å·¦ä¾§ä¹‹å¤– */

    background-color: white;
    /* å­—ä½“åå¤‡ï¼Œé˜²æ­¢æ¸²æŸ“å™¨æ‰¾ä¸åˆ°å­—ä½“å¯¼è‡´å†…å®¹ç¼ºå¤± */
    font-family: Arial, "Microsoft YaHei", sans-serif;
 }

 /* å¼ºåˆ¶è¡¨æ ¼æ ·å¼ */
 #pdf-content table {
    width: 100%;
    border-collapse: collapse;
    font-size: 7pt; /* æ•´ä½“å­—ä½“å¤§å° */
    /* é¿å…è¡¨æ ¼åœ¨ html2canvas ä¸­è¢«å‹ç¼©ï¼Œç¡®ä¿å¸ƒå±€ç¨³å®š */
    table-layout: fixed;
 }

 /* è¡¨æ ¼é€šç”¨å•å…ƒæ ¼æ ·å¼ */
 #pdf-content td, #pdf-content th {
    border: 1px solid #ddd;
    padding: 5px;
    text-align: center;
    height: 15px; /* ç¡®ä¿æœ€å°é«˜åº¦ */
    vertical-align: top; /* é¡¶éƒ¨å¯¹é½ï¼Œé˜²æ­¢å¤‡æ³¨æ¢è¡Œåé«˜åº¦è®¡ç®—ä¸å‡†ç¡® */
 }

 /* è¡¨å¤´æ ·å¼ */
 #pdf-content thead th {
    background-color: #007AFF; /* è“è‰²åº•è‰² */
    color: white;
    font-weight: bold;
    page-break-inside: avoid; 
 }

 /* å¤‡æ³¨å­—æ®µç‰¹æ®Šæ ·å¼ */
 #pdf-content .notes-cell {
    color: #d32f2f; /* æ·±çº¢è‰²å­—ä½“ */
    text-align: left !important; /* é å·¦å¯¹é½ */
    /* å…è®¸å¹¶ä¿ç•™æ¢è¡Œç¬¦ï¼Œå®ç°è‡ªåŠ¨æ¢è¡Œ */
    white-space: pre-wrap; 
 }

 /* é¡µè„šæ ·å¼ */
 #pdf-content .pdf-footer {
    /* åœ¨ç»å¯¹å®šä½çš„çˆ¶å…ƒç´ ä¸­ï¼Œä½¿ç”¨ fixed å¯èƒ½ä¼šå¯¼è‡´æ¸²æŸ“é—®é¢˜ï¼Œæ”¹ç”¨ç»å¯¹å®šä½ */
    position: absolute;
    bottom: 5mm;
    width: 100%; /* ç»§æ‰¿ 250mm å®¹å™¨çš„å®½åº¦ */
    left: 0;
    text-align: center;
    font-size: 6pt;
    color: #999; 
 }
 
 /* äº‘ç«¯å­˜å‚¨çŠ¶æ€æŒ‡ç¤ºå™¨ */
 .cloud-status {
    display: inline-flex;
    align-items: center;
    padding: 4px 8px;
    border-radius: 12px;
    font-size: 12px;
    font-weight: 600;
 }
 
 .cloud-status.connected {
    background-color: #e6f4ea;
    color: #137333;
 }
 
 .cloud-status.disconnected {
    background-color: #fce8e6;
    color: #c5221f;
 }
 
 .cloud-status.syncing {
    background-color: #e8f0fe;
    color: #1a73e8;
 }
 </style>
</head>
<body>
 <div id="app" v-cloak>
 <div class="app-header">
 <div class="max-w-7xl mx-auto px-4 py-4 sm:px-6 lg:px-8">
 <div class="flex flex-col sm:flex-row justify-between items-center">
 <div class="mb-4 sm:mb-0 text-center sm:text-left">
 <h1 class="text-2xl sm:text-3xl font-bold flex items-center justify-center sm:justify-start">
 <span class="mr-2">ğŸ­</span>
 å®‡ä¸œçººç»‡æŠ¥ä»·ç³»ç»Ÿ
 <span class="ml-2 text-sm bg-white text-green-700 px-2 py-1 rounded-full">æ™ºèƒ½äº‘ç«¯ç‰ˆ V4.1</span>
 </h1>
 <p class="text-sm mt-1 opacity-90">æ™ºèƒ½æŸ¥è¯¢ Â· äº‘ç«¯å­˜å‚¨ Â· è‡ªåŠ¨å›¾ç‰‡æ˜ å°„</p>
 </div>
 <div class="flex flex-wrap gap-4 justify-center">
 <div class="stat-card rounded-lg px-4 py-2 text-center">
 <div class="text-2xl font-bold text-purple-600">{{ Object.keys(catalogData).length }}</div>
 <div class="text-xs text-gray-600">äº§å“æ•°æ®</div>
 </div>
 <div class="stat-card rounded-lg px-4 py-2 text-center">
 <div class="text-2xl font-bold text-purple-600">{{ uploadedFiles.length }}</div>
 <div class="text-xs text-gray-600">æ–‡ä»¶æ•°</div>
 </div>
 <div class="stat-card rounded-lg px-4 py-2 text-center">
 <div class="text-2xl font-bold text-purple-600">{{ totalResults }}</div>
 <div class="text-xs text-gray-600">æŸ¥è¯¢ç»“æœ</div>
 </div>
 </div>
 </div>
 <div class="mt-4 text-center">
 <div class="cloud-status" :class="cloudStatus">
 <el-icon class="mr-1" v-if="cloudStatus === 'connected'"><SuccessFilled /></el-icon>
 <el-icon class="mr-1" v-else-if="cloudStatus === 'disconnected'"><WarningFilled /></el-icon>
 <el-icon class="mr-1" v-else><Loading /></el-icon>
 {{ cloudStatusText }}
 </div>
 </div>
 </div>
 </div>

 <div class="max-w-7xl mx-auto px-4 py-6 sm:px-6 lg:px-8">
 <el-tabs v-model="activeTab" type="border-card" class="shadow-lg">
 <el-tab-pane name="search">
 <template #label>
 <span class="flex items-center">
 <el-icon class="mr-2"><Search /></el-icon>
 <span class="hidden sm:inline">æŠ¥ä»·æŸ¥è¯¢</span>
 <span class="sm:hidden">æŸ¥è¯¢</span>
 </span>
 </template>
 
 <div class="p-4">
 <el-card shadow="hover" class="mb-6">
 <template #header>
 <div class="flex items-center justify-between">
 <span class="font-semibold">ğŸ” æ™ºèƒ½æœç´¢</span>
 <el-button size="small" @click="clearSearch" :disabled="!searchInput">
 æ¸…ç©º
 </el-button>
 </div>
 </template>
 
 <div class="search-input-wrapper mb-4">
 <el-input
 v-model="searchInput"
 type="textarea"
 :rows="3"
 placeholder="è¾“å…¥äº§å“ä»£ç ã€ä¾›åº”å•†æˆ–ä»·æ ¼/å…‹é‡åŒºé—´...&#10;&#10;ç¤ºä¾‹ï¼šC6001, Y6, æ°¸è”, 20å…ƒä»¥ä¸Š, 100å…‹å†…"
 @input="handleSearchInput"
 clearable
 >
 <template #prepend>
 <el-icon><Search /></el-icon>
 </template>
 </el-input>
 
 <div v-if="showAutocomplete && autocompleteItems.length > 0" 
 class="absolute z-10 w-full bg-white shadow-lg rounded-lg mt-2 max-h-60 overflow-y-auto border">
 <div v-for="item in autocompleteItems" 
 :key="item"
 class="autocomplete-item"
 @click="selectAutocomplete(item)">
 {{ item }}
 </div>
 </div>
 </div>
 
 <div class="text-sm text-gray-600 bg-blue-50 p-3 rounded-lg mb-4">
 ğŸ’¡ å®æ—¶æ™ºèƒ½æœç´¢ï¼šæ”¯æŒäº§å“ä»£ç ã€ä¾›åº”å•†ã€ä»·æ ¼/å…‹é‡åŒºé—´æŸ¥è¯¢ï¼Œè¾“å…¥å³è‡ªåŠ¨åŒ¹é…
 </div>
 
 <div v-if="searchHistory.length > 0" class="mb-4">
 <div class="text-sm text-gray-500 mb-2">æœç´¢å†å²ï¼š</div>
 <div class="flex flex-wrap gap-2">
 <el-tag
 v-for="(history, index) in searchHistory.slice(-5).reverse()"
 :key="index"
 class="cursor-pointer"
 @click="loadHistory(history)"
 effect="plain"
 >
 {{ history }}
 </el-tag>
 </div>
 </div>
 
 <!-- æœç´¢/å¯¼å‡º/æ¸…é™¤å†å² æŒ‰é’®å¸ƒå±€ (å…¨å®½å‚ç›´å †å ) -->
 <div class="mobile-btn-stack">
    <el-button type="primary" @click="performSearch" :loading="searching">
        <el-icon class="mr-1"><Search /></el-icon>
        æœç´¢
    </el-button>
    <el-button 
        type="success" 
        @click="exportQuotePDF" 
        :disabled="totalResults === 0"
        v-if="totalResults > 0"
    >
        <el-icon class="mr-1"><Document /></el-icon>
        å¯¼å‡ºPDFæŠ¥ä»·
    </el-button>
    <el-button @click="clearSearchHistory" v-if="searchHistory.length > 0">
        <el-icon class="mr-1"><Delete /></el-icon>
        æ¸…é™¤å†å²
    </el-button>
 </div>
 </el-card>
 
 <el-alert
 v-if="fuzzyMatches.length > 0"
 type="warning"
 :closable="false"
 class="mb-4"
 >
 <template #title>
 <div class="font-semibold">ğŸ¯ æ‰¾åˆ° {{ fuzzyMatches.length }} ä¸ªæ¨¡ç³ŠåŒ¹é…</div>
 </template>
 <div v-for="(fuzzy, index) in fuzzyMatches" :key="index" class="mb-3">
 <div class="text-sm mb-2">æœç´¢ "{{ fuzzy.searchTerm }}" æ‰¾åˆ° {{ fuzzy.matches.length }} ä¸ªç»“æœï¼š</div>
 <div class="flex flex-wrap gap-2">
 <el-button
 v-for="match in fuzzy.matches"
 :key="match"
 size="small"
 class="fuzzy-match-btn"
 @click="selectFuzzyMatch(match)"
 >
 {{ match }}
 </el-button>
 </div>
 </div>
 </el-alert>
 
 <el-alert
 v-if="totalResults > 0"
 type="success"
 :closable="false"
 class="mb-4"
 >
 <template #title>
 æœ¬æ¬¡æŸ¥è¯¢æ‰¾åˆ° <strong class="text-lg">{{ totalResults }}</strong> ä¸ªåŒ¹é…ç»“æœ
 </template>
 </el-alert>
 
 <div v-if="rangeResults.length > 0">
 <el-card 
 v-for="(range, index) in rangeResults" 
 :key="index"
 shadow="hover"
 class="mb-4"
 >
 <template #header>
 <div class="flex justify-between items-center">
 <span class="font-bold text-lg">{{ range.label }}</span>
 <el-tag type="info">{{ range.matches.length }} ä¸ªäº§å“</el-tag>
 </div>
 </template>
 
 <div class="mb-4 bg-gray-50 p-3 rounded-lg">
 <div class="text-sm font-semibold text-gray-700 mb-2">
 ğŸ“‹ åŒ¹é…äº§å“ç¼–å· ({{ range.matches.length }} ä¸ª)
 </div>
 <div class="flex flex-wrap gap-2">
 <el-tag
 v-for="product in range.matches"
 :key="product.code"
 class="cursor-pointer"
 @click="scrollToProduct(product.code)"
 effect="plain"
 >
 {{ product.code }}
 </el-tag>
 </div>
 </div>
 
 <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
 <product-card
 v-for="product in range.matches"
 :key="product.code"
 :product="product"
 @view-image="viewImage"
 />
 </div>
 </el-card>
 </div>
 
 <div v-if="searchResults.length > 0" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
 <product-card
 v-for="result in searchResults"
 :key="result.code"
 :product="result"
 @view-image="viewImage"
 />
 </div>
 
 <el-empty 
 v-if="totalResults === 0 && !searching && searchInput === ''"
 description="è¯·è¾“å…¥äº§å“ä»£ç æˆ–æŸ¥è¯¢æ¡ä»¶å¼€å§‹æœç´¢"
 :image-size="200"
 />
 
 <el-empty 
 v-if="totalResults === 0 && !searching && searchInput !== ''"
 description="æœªæ‰¾åˆ°åŒ¹é…çš„äº§å“"
 :image-size="200"
 />
 </div>
 </el-tab-pane>

 <el-tab-pane name="manage">
 <template #label>
 <span class="flex items-center">
 <el-icon class="mr-2"><Setting /></el-icon>
 <span class="hidden sm:inline">æ•°æ®ç®¡ç†</span>
 <span class="sm:hidden">ç®¡ç†</span>
 </span>
 </template>
 
 <div class="p-4">
 <el-card shadow="hover" class="mb-6">
 <template #header>
 <span class="font-semibold">
 {{ editingProduct ? 'âœï¸ ç¼–è¾‘äº§å“' : 'â• æ·»åŠ äº§å“' }}
 </span>
 </template>
 
 <el-form :model="productForm" label-width="80px" label-position="top">
 <div class="grid grid-cols-1 md:col-span-2 lg:grid-cols-3 gap-4">
 <el-form-item label="äº§å“ä»£ç " required>
 <el-input 
 v-model="productForm.code" 
 placeholder="ä¾‹: C6001"
 :disabled="editingProduct !== null"
 />
 </el-form-item>
 <el-form-item label="ç ä»·">
 <el-input v-model="productForm.price" placeholder="å…ƒ/ç " />
 </el-form-item>
 <el-form-item label="ç±³ä»·">
 <el-input v-model="productForm.priceAlt" placeholder="å…ƒ/ç±³" />
 </el-form-item>
 <el-form-item label="é—¨å¹…">
 <el-input v-model="productForm.width" placeholder="cm" />
 </el-form-item>
 <el-form-item label="æˆåˆ†">
 <el-input v-model="productForm.composition" placeholder="æè´¨æˆåˆ†" />
 </el-form-item>
 <el-form-item label="å…‹é‡">
 <el-input v-model="productForm.weight" placeholder="g/ã¡" />
 </el-form-item>
 <el-form-item label="ä¾›åº”å•†" class="md:col-span-2">
 <el-input v-model="productForm.supplier" placeholder="ä¾›åº”å•†åç§°" />
 </el-form-item>
 <el-form-item label="å¤‡æ³¨" class="md:col-span-3">
 <el-input 
 v-model="productForm.notes" 
 type="textarea"
 :rows="2"
 placeholder="å¤‡æ³¨ä¿¡æ¯"
 />
 </el-form-item>
 </div>
 
 <!-- æ›´æ–°/åˆ é™¤/é‡ç½® æŒ‰é’®å¸ƒå±€ (å…¨å®½å‚ç›´å †å ) -->
 <div class="mobile-btn-stack mt-4">
    <el-button 
        type="primary" 
        @click="saveProduct"
        :loading="saving"
        class="sm:w-auto"
    >
        <el-icon class="mr-1"><Check /></el-icon>
        {{ editingProduct ? 'æ›´æ–°äº§å“' : 'æ·»åŠ äº§å“' }}
    </el-button>
    <el-button 
        v-if="editingProduct"
        type="danger"
        @click="deleteProduct"
        class="sm:w-auto"
    >
        <el-icon class="mr-1"><Delete /></el-icon>
        åˆ é™¤äº§å“
    </el-button>
    <el-button @click="resetForm" class="sm:w-auto">
        <el-icon class="mr-1"><RefreshLeft /></el-icon>
        é‡ç½®è¡¨å•
    </el-button>
 </div>
 </el-form>
 </el-card>
 
 <el-card shadow="hover">
 <template #header>
 <div class="flex justify-between items-center">
 <span class="font-semibold">ğŸ“¦ äº§å“åˆ—è¡¨ ({{ filteredProducts.length }})</span>
 <el-input
 v-model="manageSearchTerm"
 placeholder="æœç´¢äº§å“ä»£ç æˆ–ä¾›åº”å•†"
 clearable
 class="w-64"
 >
 <template #prefix>
 <el-icon><Search /></el-icon>
 </template>
 </el-input>
 </div>
 </template>
 
 <!-- ä¿®å¤ç‚¹ï¼šæ·»åŠ  v-if="isDataLoaded" å»¶è¿Ÿåˆ—è¡¨æ¸²æŸ“ -->
 <div v-if="!isDataLoaded" class="py-12 text-center text-gray-500">
    <el-icon><Loading /></el-icon> æ­£åœ¨ä»äº‘ç«¯æ•°æ®åº“åŠ è½½æ•°æ®...
 </div>
 
 <div v-else>
 <div class="hidden md:block">
 <el-table
 :data="paginatedProducts"
 stripe
 style="width: 100%"
 :default-sort="{ prop: 'code', order: 'ascending' }"
 :key="listKey" 
 >
 <el-table-column prop="code" label="äº§å“ä»£ç " width="120" sortable>
    <template #default="{ row }">
        <!-- ä¿®å¤ç‚¹ï¼šrow.code å·²ç»ç¡®ä¿å­˜åœ¨ -->
        <span class="font-bold text-purple-600">{{ row.code }}</span>
    </template>
 </el-table-column>
 <el-table-column prop="price" label="ç ä»·" width="100">
    <template #default="{ row }">{{ row.price }}</template>
 </el-table-column>
 <el-table-column prop="priceAlt" label="ç±³ä»·" width="100">
    <template #default="{ row }">{{ row.priceAlt }}</template>
 </el-table-column>
 <el-table-column prop="width" label="é—¨å¹…" width="100">
    <template #default="{ row }">{{ row.width }}</template>
 </el-table-column>
 <el-table-column prop="composition" label="æˆåˆ†" min-width="150" show-overflow-tooltip>
    <template #default="{ row }">{{ row.composition }}</template>
 </el-table-column>
 <el-table-column prop="weight" label="å…‹é‡" width="100">
    <template #default="{ row }">{{ row.weight }}</template>
 </el-table-column>
 <el-table-column prop="supplier" label="ä¾›åº”å•†" width="120" show-overflow-tooltip>
    <template #default="{ row }">{{ row.supplier }}</template>
 </el-table-column>
 <el-table-column label="åº•å¡å›¾ç‰‡" width="120">
    <template #default="{ row }">
        <el-button 
            v-if="getProductImageUrl(row.code)" 
            size="small" 
            type="primary"
            @click="viewImage(getProductImageUrl(row.code))"
        >
            æŸ¥çœ‹å›¾ç‰‡
        </el-button>
        <span v-else class="text-gray-400">æ— å›¾ç‰‡</span>
    </template>
 </el-table-column>
 <el-table-column label="æ“ä½œ" width="180" fixed="right">
 <template #default="{ row }">
 <el-button size="small" @click="editProduct(row.code)">
 ç¼–è¾‘
 </el-button>
 <el-button 
 size="small" 
 type="danger"
 @click="confirmDelete(row.code)"
 >
 åˆ é™¤
 </el-button>
 </template>
 </el-table-column>
 </el-table>
 </div>
 
 <!-- ç§»åŠ¨ç«¯åˆ—è¡¨ -->
 <div class="md:hidden" :key="listKey + 'mobile'">
 <div 
 v-for="product in paginatedProducts"
 :key="product.code"
 class="border rounded-lg p-4 mb-3 hover:shadow-md transition-shadow cursor-pointer bg-white text-gray-800"
 @click="editProduct(product.code)"
 >
 <div class="flex justify-between items-start mb-2">
 <div class="font-bold text-lg text-purple-600">{{ product.code }}</div>
 <!-- æ›¿æ¢ä¸º el-tag -->
 <el-tag 
 type="danger" 
 effect="dark" 
 @click.stop="confirmDelete(product.code)"
 class="mobile-tag-delete"
 >
 åˆ é™¤
 </el-tag>
 </div>
 <div class="text-sm text-gray-700 space-y-1">
 <div><span class="font-semibold">ç ä»·:</span> {{ product.price }}</div>
 <div><span class="font-semibold">ç±³ä»·:</span> {{ product.priceAlt }}</div>
 <div><span class="font-semibold">é—¨å¹…:</span> {{ product.width }}</div>
 <div><span class="font-semibold">æˆåˆ†:</span> {{ product.composition }}</div>
 <div><span class="font-semibold">å…‹é‡:</span> {{ product.weight }}</div>
 <div><span class="font-semibold">ä¾›åº”å•†:</span> {{ product.supplier }}</div>
 <div v-if="product.notes && product.notes !== '-'"><span class="font-semibold">å¤‡æ³¨:</span> {{ product.notes }}</div>
 <div v-if="getProductImageUrl(product.code)" class="mt-2">
    <el-button 
        size="small" 
        type="primary"
        @click.stop="viewImage(getProductImageUrl(product.code))"
    >
        æŸ¥çœ‹åº•å¡å›¾ç‰‡
    </el-button>
 </div>
 </div>
 </div>
 </div>
 
 <div class="mt-4 flex justify-center">
 <el-pagination
 v-model:current-page="currentPage"
 :page-size="pageSize"
 :total="filteredProducts.length"
 layout="prev, pager, next, jumper"
 :small="isMobile"
 />
 </div>
 </div>
 </el-card>
 </div>
 </el-tab-pane>

 <el-tab-pane name="cloud">
 <template #label>
 <span class="flex items-center">
 <el-icon class="mr-2"><Cloudy /></el-icon>
 <span class="hidden sm:inline">äº‘ç«¯å­˜å‚¨</span>
 <span class="sm:hidden">äº‘ç«¯</span>
 </span>
 </template>
 
 <div class="p-4">
 <el-card shadow="hover" class="mb-6">
 <template #header>
 <span class="font-semibold">ğŸ–¼ï¸ æ™ºèƒ½å›¾ç‰‡æ˜ å°„é…ç½®</span>
 </template>
 
 <div class="space-y-4">
 <div class="p-4 bg-green-50 rounded-lg">
 <h3 class="font-bold text-green-800 mb-2">æ™ºèƒ½å›¾ç‰‡æ˜ å°„åŠŸèƒ½</h3>
 <p class="text-sm text-green-700">
 åªéœ€é…ç½®ä¸€æ¬¡Google Driveç›¸å†Œé“¾æ¥ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨æ ¹æ®äº§å“ä»£ç åŒ¹é…å¯¹åº”çš„å›¾ç‰‡ï¼
 </p>
 </div>
 
 <el-form :model="cloudConfig" label-width="120px">
 <el-form-item label="Google Driveç›¸å†Œé“¾æ¥">
 <el-input 
 v-model="cloudConfig.folderUrl" 
 placeholder="https://drive.google.com/drive/folders/æ–‡ä»¶å¤¹ID"
 @change="updateCloudConfig"
 >
 <template #append>
 <el-button @click="testFolderConnection">æµ‹è¯•è¿æ¥</el-button>
 </template>
 </el-input>
 <div class="text-xs text-gray-500 mt-1">
 è¯·ç¡®ä¿æ–‡ä»¶å¤¹å·²è®¾ç½®ä¸º"çŸ¥é“é“¾æ¥çš„ä»»ä½•äººå¯æŸ¥çœ‹"
 </div>
 </el-form-item>
 
 <el-form-item label="å›¾ç‰‡å‘½åè§„åˆ™">
 <el-radio-group v-model="cloudConfig.namingRule" @change="updateCloudConfig">
 <el-radio label="exact">ç²¾ç¡®åŒ¹é… (C6001.jpg)</el-radio>
 <el-radio label="prefix">å‰ç¼€åŒ¹é… (C6001_1.jpg)</el-radio>
 </el-radio-group>
 </el-form-item>
 
 <el-form-item label="å›¾ç‰‡æ‰©å±•å">
 <el-checkbox-group v-model="cloudConfig.extensions" @change="updateCloudConfig">
 <el-checkbox label="jpg">JPG</el-checkbox>
 <el-checkbox label="png">PNG</el-checkbox>
 <el-checkbox label="jpeg">JPEG</el-checkbox>
 </el-checkbox-group>
 </el-form-item>
 
 <el-form-item>
 <el-button 
 type="primary" 
 @click="scanAndMapImages"
 :loading="scanningImages"
 :disabled="!cloudConfig.folderUrl"
 >
 <el-icon class="mr-1"><Search /></el-icon>
 æ‰«æå¹¶æ˜ å°„å›¾ç‰‡
 </el-button>
 <el-button 
 @click="clearImageMapping"
 :disabled="Object.keys(imageMapping).length === 0"
 >
 <el-icon class="mr-1"><Delete /></el-icon>
 æ¸…é™¤æ˜ å°„
 </el-button>
 </el-form-item>
 </el-form>
 
 <div v-if="scanResults" class="p-4 bg-blue-50 rounded-lg">
 <h4 class="font-semibold text-blue-800">æ‰«æç»“æœ</h4>
 <div class="text-sm text-blue-700 mt-2">
 <div>æ‰¾åˆ°å›¾ç‰‡: {{ scanResults.foundImages }} ä¸ª</div>
 <div>æˆåŠŸæ˜ å°„: {{ scanResults.mappedProducts }} ä¸ªäº§å“</div>
 <div>æœªåŒ¹é…: {{ scanResults.unmatchedImages }} ä¸ªå›¾ç‰‡</div>
 </div>
 </div>
 </div>
 </el-card>
 
 <el-card shadow="hover" class="mb-6">
 <template #header>
 <span class="font-semibold">ğŸ“Š å›¾ç‰‡æ˜ å°„ç»Ÿè®¡</span>
 </template>
 
 <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
 <div class="text-center p-4 bg-purple-50 rounded-lg">
 <div class="text-2xl font-bold text-purple-600">{{ Object.keys(imageMapping).length }}</div>
 <div class="text-sm text-gray-600">å·²æ˜ å°„å›¾ç‰‡</div>
 </div>
 <div class="text-center p-4 bg-green-50 rounded-lg">
 <div class="text-2xl font-bold text-green-600">{{ mappedProductCount }}</div>
 <div class="text-sm text-gray-600">æœ‰å›¾ç‰‡çš„äº§å“</div>
 </div>
 <div class="text-center p-4 bg-blue-50 rounded-lg">
 <div class="text-2xl font-bold text-blue-600">{{ totalProductCount }}</div>
 <div class="text-sm text-gray-600">æ€»äº§å“æ•°</div>
 </div>
 <div class="text-center p-4 bg-yellow-50 rounded-lg">
 <div class="text-2xl font-bold text-yellow-600">{{ coverageRate }}%</div>
 <div class="text-sm text-gray-600">å›¾ç‰‡è¦†ç›–ç‡</div>
 </div>
 </div>
 
 <div class="mt-4">
 <h4 class="font-semibold mb-2">æœ€è¿‘æ˜ å°„çš„å›¾ç‰‡:</h4>
 <div class="flex flex-wrap gap-2">
 <el-tag
 v-for="(url, code) in recentMappedImages"
 :key="code"
 class="cursor-pointer"
 @click="viewImage(url)"
 >
 {{ code }}
 </el-tag>
 </div>
 </div>
 </el-card>
 
 <el-card shadow="hover">
 <template #header>
 <span class="font-semibold">â˜ï¸ æ•°æ®å¤‡ä»½ä¸æ¢å¤</span>
 </template>
 
 <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
 <el-card shadow="hover">
 <template #header>
 <span class="font-semibold">ğŸ“¤ ä¸Šä¼ æ•°æ®åˆ°äº‘ç«¯</span>
 </template>
 <div class="space-y-3">
 <el-button 
 type="primary" 
 @click="uploadToGoogleDrive"
 :loading="cloudUploading"
 class="w-full"
 >
 <el-icon class="mr-1"><Upload /></el-icon>
 å¤‡ä»½æ•°æ®åˆ°Google Drive
 </el-button>
 <div class="text-sm text-gray-500">
 å°†å½“å‰æ‰€æœ‰äº§å“æ•°æ®å’Œé…ç½®å¤‡ä»½åˆ°Google Drive
 </div>
 </div>
 </el-card>
 
 <el-card shadow="hover">
 <template #header>
 <span class="font-semibold">ğŸ“¥ ä»äº‘ç«¯æ¢å¤æ•°æ®</span>
 </template>
 <div class="space-y-3">
 <el-button 
 type="success" 
 @click="downloadFromGoogleDrive"
 :loading="cloudDownloading"
 class="w-full"
 >
 <el-icon class="mr-1"><Download /></el-icon>
 ä»Google Driveæ¢å¤æ•°æ®
 </el-button>
 <div class="text-sm text-gray-500">
 ä»Google Driveæ¢å¤ä¹‹å‰å¤‡ä»½çš„æ•°æ®
 </div>
 </div>
 </el-card>
 </div>
 
 <div class="mt-4">
 <el-button 
 type="warning" 
 @click="exportImageMappingReport"
 class="w-full"
 >
 <el-icon class="mr-1"><Document /></el-icon>
 å¯¼å‡ºå›¾ç‰‡æ˜ å°„æŠ¥å‘Š
 </el-button>
 </div>
 </el-card>
 </div>
 </el-tab-pane>

 <el-tab-pane name="settings">
 <template #label>
 <span class="flex items-center">
 <el-icon class="mr-2"><Tools /></el-icon>
 <span class="hidden sm:inline">ç³»ç»Ÿè®¾ç½®</span>
 <span class="sm:hidden">è®¾ç½®</span>
 </span>
 </template>
 
 <div class="p-4">
 <el-card shadow="hover" class="mb-6">
 <template #header>
 <span class="font-semibold">ğŸ“¤ æ•°æ®å¯¼å…¥</span>
 </template>
 
 <!-- å¯¼å…¥æŒ‰é’®å¸ƒå±€ (å…¨å®½å‚ç›´å †å ï¼Œå¤§é—´è·) -->
 <div class="mobile-btn-stack import-group">
    <!-- æ–‡ä»¶ä¸Šä¼ æŒ‰é’® -->
    <div>
        <el-upload
            ref="fileUpload"
            :auto-upload="false"
            :on-change="handleFileUpload"
            :show-file-list="true"
            accept=".csv,.xlsx"
            multiple
        >
            <!-- ç¡®ä¿æŒ‰é’®æ˜¯ w-full -->
            <el-button type="primary" class="sm:w-auto"> 
                <el-icon class="mr-1"><Upload /></el-icon>
                é€‰æ‹© CSV/XLSX æ–‡ä»¶
            </el-button>
        </el-upload>
    </div>
    
    <el-divider />
    
    <!-- æ•°æ®åº“å¯¼å…¥æŒ‰é’® -->
    <div>
        <el-upload
            :auto-upload="false"
            :on-change="handleDatabaseImport"
            :show-file-list="false"
            accept=".json,.zip"
        >
            <!-- ç¡®ä¿æŒ‰é’®æ˜¯ w-full -->
            <el-button type="success" class="sm:w-auto"> 
                <el-icon class="mr-1"><Download /></el-icon>
                å¯¼å…¥æ•°æ®åº“å¤‡ä»½ (JSON/ZIP)
            </el-button>
        </el-upload>
    </div>
 </div>
 </el-card>
 
 <el-card shadow="hover" class="mb-6">
 <template #header>
 <span class="font-semibold">ğŸ“¥ æ•°æ®å¯¼å‡º</span>
 </template>
 
 <div class="space-y-3">
 <el-button 
 type="success" 
 @click="exportAllData"
 :disabled="Object.keys(catalogData).length === 0"
 class="w-full sm:w-auto"
 >
 <el-icon class="mr-1"><FolderOpened /></el-icon>
 å¯¼å‡ºå®Œæ•´æ•°æ®åº“ (ZIP)
 </el-button>
 <div class="text-sm text-gray-500">
 åŒ…å«æ‰€æœ‰äº§å“æ•°æ®ã€å›¾ç‰‡é“¾æ¥å’Œå†å²è®°å½•
 </div>
 </div>
 </el-card>
 
 <el-card shadow="hover" class="mb-6" v-if="uploadedFiles.length > 0">
 <template #header>
 <span class="font-semibold">ğŸ“„ å·²å¯¼å…¥æ–‡ä»¶ ({{ uploadedFiles.length }})</span>
 </template>
 
 <el-timeline>
 <el-timeline-item
 v-for="(file, index) in uploadedFiles.slice().reverse()"
 :key="index"
 :timestamp="file.uploadTime"
 placement="top"
 >
 <div class="font-semibold">{{ file.name }}</div>
 <div class="text-sm text-gray-600">{{ file.count }} æ¡æ•°æ®</div>
 </el-timeline-item>
 </el-timeline>
 </el-card>
 
 <el-card shadow="hover">
 <template #header>
 <span class="font-semibold text-red-600">âš ï¸ å±é™©æ“ä½œ</span>
 </template>
 
 <el-alert
 type="error"
 :closable="false"
 class="mb-4"
 >
 <template #title>
 ä»¥ä¸‹æ“ä½œä¸å¯é€†ï¼Œè¯·è°¨æ…æ“ä½œï¼
 </template>
 </el-alert>
 
 <div class="space-y-3">
 <el-button 
 type="danger" 
 @click="clearAllData"
 class="w-full sm:w-auto"
 >
 <el-icon class="mr-1"><Delete /></el-icon>
 æ¸…ç©ºæ‰€æœ‰æ•°æ®
 </el-button>
 </div>
 </el-card>
 </div>
 </el-tab-pane>
 </el-tabs>
 </div>

 <el-dialog
 v-model="imageDialogVisible"
 title="åº•å¡å›¾ç‰‡é¢„è§ˆ"
 width="90%"
 :fullscreen="isMobile"
 >
 <div class="flex justify-center overflow-auto" style="touch-action: pinch-zoom;">
 <img :src="currentImage" class="max-w-full max-h-[70vh] object-contain" style="touch-action: pinch-zoom;" />
 </div>
 <template #footer>
 <div class="text-center">
 <el-button type="primary" @click="openImageInNewTab">åœ¨æ–°æ ‡ç­¾é¡µæ‰“å¼€</el-button>
 </div>
 </template>
 </el-dialog>

 <el-dialog
 v-model="progressVisible"
 title="å¤„ç†ä¸­"
 width="400px"
 :close-on-click-modal="false"
 :close-on-press-escape="false"
 :show-close="false"
 >
 <el-progress :percentage="progressPercentage" :status="progressStatus" />
 <div class="text-center mt-4 text-gray-600">{{ progressText }}</div>
 </el-dialog>

 <!-- PDF å¯¼å‡ºä¸“ç”¨çš„éšè—å®¹å™¨ -->
 <div id="pdf-content" style="display: none;"></div>
 </div>

 <script>
 const { createApp, ref, computed, watch, onMounted, nextTick } = Vue;
 const { ElMessage, ElMessageBox, ElNotification } = ElementPlus;

 // äº§å“å¡ç‰‡ç»„ä»¶
 const ProductCard = {
 props: ['product'],
 emits: ['view-image'],
 setup(props, { emit }) {
    const getImageUrl = () => {
        return window.getProductImageUrl ? window.getProductImageUrl(props.product.code) : null;
    };
    
    return {
        getImageUrl
    };
 },
 template: `
 <div class="product-card rounded-lg overflow-hidden bg-white" :id="'product-' + product.code">
 <div class="p-4" :class="product.found === false ? 'opacity-50' : ''">
 <div class="flex justify-between items-start mb-3">
 <div class="font-bold text-xl text-purple-600">
 ğŸ“¦ {{ product.code }}
 </div>
 <el-tag 
 :type="product.matchType === 'exact' ? 'success' : product.matchType === 'fuzzy' ? 'warning' : 'info'"
 size="small"
 v-if="product.found !== false"
 >
 {{ product.matchType === 'exact' ? 'âœ“ ç²¾ç¡®' : product.matchType === 'fuzzy' ? 'ğŸ¯ æ¨¡ç³Š' : 'ğŸ“Š åŒºé—´' }}
 </el-tag>
 <el-tag type="danger" size="small" v-else>
 âŒ æœªæ‰¾åˆ°
 </el-tag>
 </div>
 
 <div v-if="product.found === false" class="text-center py-8">
 <div class="text-4xl mb-2">âŒ</div>
 <div class="text-gray-600">{{ product.error }}</div>
 </div>
 
 <div v-else class="space-y-3">
 <div class="bg-gradient-to-r from-green-50 to-green-100 rounded-lg p-3">
 <div class="grid grid-cols-2 gap-3">
 <div>
 <div class="text-xs text-gray-600">ğŸ’° ç ä»·</div>
 <div class="text-xl font-bold text-green-600">{{ product.price }}</div>
 </div>
 <div>
 <div class="text-xs text-gray-600">ğŸ’° ç±³ä»·</div>
 <div class="text-lg font-semibold text-gray-700">{{ product.priceAlt }}</div>
 </div>
 </div>
 </div>
 
 <div class="grid grid-cols-2 gap-2 text-sm">
 <div class="bg-gray-50 p-2 rounded">
 <div class="text-xs text-gray-500">ğŸ“ é—¨å¹…</div>
 <div class="font-semibold">{{ product.width }}</div>
 </div>
 <div class="bg-gray-50 p-2 rounded">
 <div class="text-xs text-gray-500">âš–ï¸ å…‹é‡</div>
 <div class="font-semibold">{{ product.weight }}</div>
 </div>
 </div>
 
 <div class="bg-gray-50 p-2 rounded text-sm">
 <div class="text-xs text-gray-500 mb-1">ğŸ§µ æˆåˆ†</div>
 <div class="font-semibold">{{ product.composition }}</div>
 </div>
 
 <div v-if="product.notes && product.notes !== '-'" class="bg-red-50 border-l-4 border-red-400 p-3 text-sm">
 <div class="text-xs font-bold text-red-700 mb-1">âš ï¸ å¤‡æ³¨</div>
 <div class="text-red-800">{{ product.notes }}</div>
 </div>
 
 <div class="flex justify-between items-center bg-purple-50 p-3 rounded-lg">
 <div class="text-sm">
 <span class="text-gray-600">ä¾›åº”å•†:</span>
 <span class="font-semibold ml-2">{{ product.supplier }}</span>
 </div>
 <el-button 
 v-if="getImageUrl()"
 size="small"
 type="primary"
 @click="$emit('view-image', getImageUrl())"
 >
 ğŸ–¼ï¸ æŸ¥çœ‹åº•å¡
 </el-button>
 </div>
 </div>
 </div>
 </div>
 `
 };

 const app = createApp({
 components: {
 'product-card': ProductCard
 },
 setup() {
 // IndexedDB
 const DB_NAME = 'YudongFabricCloudDB';
 const DB_VERSION = 3; // ç‰ˆæœ¬å‡çº§ä»¥æ”¯æŒæ™ºèƒ½å›¾ç‰‡æ˜ å°„
 const STORE_NAME = 'catalogData';
 const CLOUD_CONFIG_STORE = 'cloudConfig';
 let db = null;

 // å“åº”å¼æ•°æ®
 const activeTab = ref('search');
 const catalogData = ref({});
 const uploadedFiles = ref([]);
 const searchHistory = ref([]);
 const searchInput = ref('');
 const searchResults = ref([]);
 const fuzzyMatches = ref([]);
 const rangeResults = ref([]);
 const searching = ref(false);
 const manageSearchTerm = ref('');
 const currentPage = ref(1);
 const pageSize = ref(20);
 const listKey = ref(0); 
 
 // --- æ ¸å¿ƒä¿®å¤ç‚¹ï¼šæ•°æ®åŠ è½½çŠ¶æ€æ ‡è®° ---
 const isDataLoaded = ref(false);

 // äº§å“è¡¨å•
 const productForm = ref({
 code: '',
 price: '',
 priceAlt: '',
 width: '',
 composition: '',
 weight: '',
 notes: '',
 supplier: ''
 });
 const editingProduct = ref(null);
 const saving = ref(false);
 
 // å›¾ç‰‡é¢„è§ˆ
 const imageDialogVisible = ref(false);
 const currentImage = ref('');
 
 // è¿›åº¦æ¡
 const progressVisible = ref(false);
 const progressPercentage = ref(0);
 const progressStatus = ref('');
 const progressText = ref('');
 
 // è‡ªåŠ¨å®Œæˆ
 const showAutocomplete = ref(false);
 const autocompleteItems = ref([]);
 
 // ç§»åŠ¨ç«¯æ£€æµ‹
 const isMobile = ref(window.innerWidth < 768);
 
 // äº‘ç«¯å­˜å‚¨ç›¸å…³
 const cloudStatus = ref('connected'); // ä¿®å¤ï¼šé»˜è®¤æ˜¾ç¤ºå·²è¿æ¥
 const cloudStatusText = ref('æ™ºèƒ½äº‘ç«¯å­˜å‚¨å·²å°±ç»ª'); // ä¿®å¤ï¼šæ›´æ–°çŠ¶æ€æ–‡æœ¬
 const cloudUploading = ref(false);
 const cloudDownloading = ref(false);
 const cloudBackups = ref([]);
 
 // æ™ºèƒ½å›¾ç‰‡æ˜ å°„ç›¸å…³
 const cloudConfig = ref({
 folderUrl: '',
 namingRule: 'exact', // 'exact' or 'prefix'
 extensions: ['jpg', 'png', 'jpeg']
 });
 
 const imageMapping = ref({}); // å­˜å‚¨äº§å“ä»£ç åˆ°å›¾ç‰‡URLçš„æ˜ å°„
 const scanningImages = ref(false);
 const scanResults = ref(null);

 // è®¡ç®—å±æ€§
 const totalResults = computed(() => {
 let count = searchResults.value.filter(r => r.found !== false).length;
 rangeResults.value.forEach(r => {
 count += r.matches.length;
 });
 return count;
 });
 
 const filteredProducts = computed(() => {
  if (!isDataLoaded.value) {
      return [];
  }
  
  const term = manageSearchTerm.value.toUpperCase();
  if (!term) return Object.values(catalogData.value);
  
  return Object.values(catalogData.value).filter(p => {
      const code = p.code ? String(p.code).toUpperCase() : '';
      const supplier = p.supplier ? String(p.supplier).toUpperCase() : '';
      return code.includes(term) || supplier.includes(term);
  });
 });
 
 const paginatedProducts = computed(() => {
 const start = (currentPage.value - 1) * pageSize.value;
 const end = start + pageSize.value;
 return filteredProducts.value.slice(start, end);
 });
 
 // å›¾ç‰‡æ˜ å°„ç»Ÿè®¡
 const mappedProductCount = computed(() => {
    return Object.values(catalogData.value).filter(product => 
        imageMapping.value[product.code]
    ).length;
 });
 
 const totalProductCount = computed(() => {
    return Object.keys(catalogData.value).length;
 });
 
 const coverageRate = computed(() => {
    if (totalProductCount.value === 0) return 0;
    return Math.round((mappedProductCount.value / totalProductCount.value) * 100);
 });
 
 const recentMappedImages = computed(() => {
    return Object.fromEntries(
        Object.entries(imageMapping.value).slice(-10)
    );
 });

 // ç›‘å¬æ•°æ®å˜åŒ–
 watch(catalogData, () => {
    listKey.value++;
    if (manageSearchTerm.value !== '') {
        const currentTerm = manageSearchTerm.value; 
        manageSearchTerm.value = ''; 
        nextTick(() => {
             manageSearchTerm.value = currentTerm;
        });
    }
 }, { deep: true });
 
 watch(manageSearchTerm, () => {
    currentPage.value = 1;
 });

 // IndexedDB åˆå§‹åŒ–
 const initDB = () => {
 return new Promise((resolve, reject) => {
  const request = indexedDB.open(DB_NAME, DB_VERSION);
  request.onerror = () => reject(request.error);
  request.onsuccess = () => {
  db = request.result;
  resolve(db);
  };
  request.onupgradeneeded = (e) => {
  db = e.target.result;
  if (!db.objectStoreNames.contains(STORE_NAME)) {
  db.createObjectStore(STORE_NAME, { keyPath: 'code' });
  }
  if (!db.objectStoreNames.contains(CLOUD_CONFIG_STORE)) {
  db.createObjectStore(CLOUD_CONFIG_STORE, { keyPath: 'id' });
  }
  };
 });
 };
 
 // ä¿å­˜æ•°æ® - ä¿®å¤ï¼šç¡®ä¿æ•°æ®å¯åºåˆ—åŒ–
 const saveData = async () => {
  if (!db) await initDB();
  const tx = db.transaction([STORE_NAME, CLOUD_CONFIG_STORE], 'readwrite');
  const store = tx.objectStore(STORE_NAME);
  const cloudStore = tx.objectStore(CLOUD_CONFIG_STORE);
  
  if (Object.keys(catalogData.value).length === 0) {
      store.clear();
  }
  
  // ä¿®å¤ï¼šç¡®ä¿æ•°æ®æ˜¯å¯åºåˆ—åŒ–çš„æ™®é€šå¯¹è±¡
  const plainCatalogData = JSON.parse(JSON.stringify(catalogData.value));
  Object.entries(plainCatalogData).forEach(([code, product]) => {
      store.put({ ...product, code });
  });
  
  // ä¿å­˜äº‘ç«¯é…ç½® - ä¿®å¤ï¼šç¡®ä¿æ•°æ®å¯åºåˆ—åŒ–
  const plainCloudConfig = JSON.parse(JSON.stringify(cloudConfig.value));
  cloudStore.put({ id: 'cloudConfig', ...plainCloudConfig });
  
  const plainImageMapping = JSON.parse(JSON.stringify(imageMapping.value));
  cloudStore.put({ id: 'imageMapping', data: plainImageMapping });
  
  // ä¿®å¤ï¼šç¡®ä¿è¿™äº›æ•°ç»„ä¹Ÿæ˜¯å¯åºåˆ—åŒ–çš„
  localStorage.setItem('fabric-uploaded-files', JSON.stringify(uploadedFiles.value));
  localStorage.setItem('search-history', JSON.stringify(searchHistory.value));
  
  return new Promise((resolve, reject) => {
  tx.oncomplete = () => resolve();
  tx.onerror = () => reject(tx.error);
  });
 };
 
 // åŠ è½½æ•°æ®
 const loadData = async () => {
  try {
  if (!db) await initDB();
  const tx = db.transaction([STORE_NAME, CLOUD_CONFIG_STORE], 'readonly');
  const store = tx.objectStore(STORE_NAME);
  const cloudStore = tx.objectStore(CLOUD_CONFIG_STORE);
  
  const request = store.getAll();
  const cloudConfigRequest = cloudStore.get('cloudConfig');
  const imageMappingRequest = cloudStore.get('imageMapping');
  
  return new Promise((resolve, reject) => {
  request.onsuccess = () => {
  const dataArray = request.result;
  catalogData.value = dataArray.reduce((acc, item) => {
  const { code, ...product } = item;
  acc[code] = { ...product, code };
  return acc;
  }, {});
  
  uploadedFiles.value = JSON.parse(localStorage.getItem('fabric-uploaded-files') || '[]');
  searchHistory.value = JSON.parse(localStorage.getItem('search-history') || '[]');
  
  currentPage.value = 1; 
  isDataLoaded.value = true;
  listKey.value++;
  
  resolve();
  };
  
  cloudConfigRequest.onsuccess = () => {
      if (cloudConfigRequest.result) {
          const { id, ...config } = cloudConfigRequest.result;
          Object.assign(cloudConfig.value, config);
      }
  };
  
  imageMappingRequest.onsuccess = () => {
      if (imageMappingRequest.result) {
          imageMapping.value = imageMappingRequest.result.data || {};
      }
  };
  
  request.onerror = (e) => {
      console.error('IndexedDB load error:', e);
      isDataLoaded.value = true; 
      listKey.value++;
      reject(e.target.error);
  };
  });
  } catch (error) {
  console.error('IndexedDB load failed:', error);
  isDataLoaded.value = true; 
  listKey.value++;
  uploadedFiles.value = JSON.parse(localStorage.getItem('fabric-uploaded-files') || '[]');
  searchHistory.value = JSON.parse(localStorage.getItem('search-history') || '[]');
  }
 };
 
 // æœç´¢åŠŸèƒ½
 let searchTimeout = null;
 const handleSearchInput = () => {
  clearTimeout(searchTimeout);
  const value = searchInput.value.trim();
  
  if (value && value.length >= 2) {
  const matches = Object.keys(catalogData.value).filter(code => 
  code.toUpperCase().includes(value.toUpperCase())
  ).slice(0, 10);
  
  const suppliers = [...new Set(
  Object.values(catalogData.value)
  .filter(p => p.supplier && p.supplier !== '-' && 
  p.supplier.toUpperCase().includes(value.toUpperCase()))
  .map(p => p.supplier)
  )].slice(0, 5);
  
  autocompleteItems.value = [...matches, ...suppliers];
  showAutocomplete.value = autocompleteItems.value.length > 0;
  } else {
  showAutocomplete.value = false;
  }
  
  if (value && Object.keys(catalogData.value).length > 0) {
  searchTimeout = setTimeout(() => {
  performSearch();
  }, 300);
  } else {
  searchResults.value = [];
  fuzzyMatches.value = [];
  rangeResults.value = [];
  }
 };
 
 const selectAutocomplete = (item) => {
  searchInput.value = item;
  performSearch();
 };
 
 // åŒºé—´æœç´¢è§£æé€»è¾‘
 const parseRangeInput = (input) => {
    const ranges = [];
    const items = input.split(/[,ï¼Œ\s;ï¼›\n]+/).map(i => i.trim()).filter(i => i);
    let type = null;
    
    items.forEach(item => {
        const upper = item.toUpperCase();
        let min = null, max = null, label = item;
        let match;

        if (upper.includes('å…ƒ') || upper.includes('Â¥')) {
            type = 'price';
            
            if (match = item.match(/([\d.]+)\s*(å…ƒ|Â¥)\s*(ä»¥ä¸Š|over)/i)) {
                min = parseFloat(match[1]);
                max = Infinity;
            } else if (match = item.match(/([\d.]+)\s*(å…ƒ|Â¥)\s*(å†…|ä»¥å†…|under)/i)) {
                max = parseFloat(match[1]);
                min = 0;
            } else if (match = item.match(/(\d+(?:\.\d+)?)\s*[-\~åˆ°]\s*(\d+(?:\.\d+)?)\s*(å…ƒ|Â¥)/i)) {
                min = parseFloat(match[1]);
                max = parseFloat(match[2]);
            }
        } 
        else if (upper.includes('å…‹') || upper.includes('G') || upper.includes('GSM') || upper.includes('å…‹é‡')) {
            type = 'weight';
            
            if (match = item.match(/([\d.]+)\s*(å…‹|g|gsm|g\/ã¡|å…‹é‡)\s*(ä»¥ä¸Š|over)/i)) {
                min = parseFloat(match[1]);
                max = Infinity;
            } else if (match = item.match(/([\d.]+)\s*(å…‹|g|gsm|g\/ã¡|å…‹é‡)\s*(å†…|ä»¥å†…|under)/i)) {
                max = parseFloat(match[1]);
                min = 0;
            } else if (match = item.match(/(\d+(?:\.\d+)?)\s*[-\~åˆ°]\s*(\d+(?:\.\d+)?)\s*(å…‹|g|gsm|g\/ã¡|å…‹é‡)/i)) {
                min = parseFloat(match[1]);
                max = parseFloat(match[2]);
            }
        }
    
        if (min !== null || max !== null) {
            if (min === null && max !== null) min = 0;
            if (max === null && min !== null) max = Infinity;
            if (min > max) [min, max] = [max, min]; 
            ranges.push({ min, max, label, type });
        }
    });

    const finalRanges = ranges.filter(r => r.type === type);
    return { ranges: finalRanges, type: type };
 };
 
 const performRangeQuery = (ranges, type) => {
  const results = [];
  const dataKeys = Object.keys(catalogData.value);
  
  ranges.forEach(range => {
  const matches = dataKeys.filter(key => {
  const product = catalogData.value[key];
  const valueStr = type === 'price' ? product.price : product.weight;
  const value = parseFloat(valueStr.match(/[\d.]+/)?.[0] || 'NaN');
  
  if (isNaN(value)) return false;
  
  const minCheck = range.min === 0 || value >= range.min;
  const maxCheck = range.max === Infinity || value <= range.max;
  return minCheck && maxCheck;
  }).map(code => ({
  ...catalogData.value[code],
  code,
  matchType: 'range'
  })).sort((a, b) => {
  const seriesA = a.code.match(/^[YC]*[ACDFGJMST]/) || [''];
  const seriesB = b.code.match(/^[YC]*[ACDFGJMST]/) || [''];
  if (seriesA[0] !== seriesB[0]) return seriesA[0].localeCompare(seriesB[0]);
  
  const numA = parseInt(a.code.replace(/^[YC]*[ACDFGJMST]/, '')) || 0;
  const numB = parseInt(b.code.replace(/^[YC]*[ACDFGJMST]/, '')) || 0;
  return numA - numB;
  });
  
  results.push({ ...range, matches });
  });
  
  return results;
 };
 
 const performSearch = () => {
  const input = searchInput.value.trim().toUpperCase();
  if (!input) {
  searchResults.value = [];
  fuzzyMatches.value = [];
  rangeResults.value = [];
  return;
  }
  
  searching.value = true;
  
  if (!searchHistory.value.includes(input)) {
  searchHistory.value.push(input);
  if (searchHistory.value.length > 10) searchHistory.value.shift();
  localStorage.setItem('search-history', JSON.stringify(searchHistory.value));
  }
  
  const parsed = parseRangeInput(searchInput.value.trim());
  if (parsed.ranges.length > 0 && (parsed.type === 'price' || parsed.type === 'weight')) {
  rangeResults.value = performRangeQuery(parsed.ranges, parsed.type);
  searchResults.value = [];
  fuzzyMatches.value = [];
  } else {
  const codes = input.split(/[\s,;\n]+/).map(c => c.trim()).filter(c => c.length > 0);
  searchResults.value = [];
  fuzzyMatches.value = [];
  rangeResults.value = [];
  
  codes.forEach(code => {
  if (catalogData.value[code]) {
  searchResults.value.push({
  ...catalogData.value[code],
  code,
  found: true,
  matchType: 'exact'
  });
  } else {
  const matches = Object.keys(catalogData.value).filter(key => {
  const product = catalogData.value[key];
  const codeMatch = key.toUpperCase().includes(code);
  const supplierMatch = product.supplier && product.supplier !== '-' && 
  product.supplier.toUpperCase().includes(code);
  return codeMatch || supplierMatch;
  });
  
  if (matches.length === 1) {
  searchResults.value.push({
  ...catalogData.value[matches[0]],
  code: matches[0],
  found: true,
  matchType: 'fuzzy'
  });
  } else if (matches.length > 1) {
  fuzzyMatches.value.push({ searchTerm: code, matches: matches.sort() });
  } else {
  searchResults.value.push({ 
  code, 
  found: false, 
  error: 'æœªæ‰¾åˆ°ç²¾ç¡®æˆ–æ¨¡ç³ŠåŒ¹é…' 
  });
  }
  }
  });
  
  searchResults.value.sort((a, b) => a.code.localeCompare(b.code));
  }
  
  searching.value = false;
 };
 
 const selectFuzzyMatch = (code) => {
  searchInput.value = code;
  performSearch();
 };
 
 const scrollToProduct = (code) => {
  nextTick(() => {
  const element = document.getElementById('product-' + code);
  if (element) {
  element.scrollIntoView({ behavior: 'smooth', block: 'center' });
  element.classList.add('ring-4', 'ring-purple-400');
  setTimeout(() => {
  element.classList.remove('ring-4', 'ring-purple-400');
  }, 2000);
  }
  });
 };
 
 const loadHistory = (history) => {
  searchInput.value = history;
  performSearch();
 };
 
 const clearSearch = () => {
  searchInput.value = '';
  searchResults.value = [];
  fuzzyMatches.value = [];
  rangeResults.value = [];
  showAutocomplete.value = false;
 };
 
 const clearSearchHistory = () => {
  ElMessageBox.confirm('ç¡®å®šè¦æ¸…é™¤æ‰€æœ‰æœç´¢å†å²å—ï¼Ÿ', 'ç¡®è®¤', {
  type: 'warning'
  }).then(() => {
  searchHistory.value = [];
  localStorage.setItem('search-history', JSON.stringify(searchHistory.value));
  ElMessage.success('æœç´¢å†å²å·²æ¸…é™¤');
  }).catch(() => {});
 };
 
 // å›¾ç‰‡å¤„ç†
 const getProductImageUrl = (productCode) => {
    if (!productCode) return null;
    
    // é¦–å…ˆæ£€æŸ¥æ˜¯å¦æœ‰æ‰‹åŠ¨è®¾ç½®çš„å›¾ç‰‡URL
    const product = catalogData.value[productCode];
    if (product && product.imageUrl) {
        return convertToDirectUrl(product.imageUrl);
    }
    
    // ç„¶åæ£€æŸ¥æ™ºèƒ½æ˜ å°„
    if (imageMapping.value[productCode]) {
        return imageMapping.value[productCode];
    }
    
    return null;
 };
 
 const convertToDirectUrl = (url) => {
    if (!url) return null;
    
    if (url.includes('drive.google.com')) {
        const fileIdMatch = url.match(/\/d\/([^\/]+)/);
        if (fileIdMatch) {
            return `https://drive.google.com/uc?export=view&id=${fileIdMatch[1]}`;
        }
        const folderIdMatch = url.match(/\/folders\/([^\/?]+)/);
        if (folderIdMatch) {
            return `https://drive.google.com/uc?export=view&id=${folderIdMatch[1]}`;
        }
    }
    
    return url;
 };
 
 const viewImage = (imageUrl) => {
    // ä¿®å¤ï¼šæ£€æŸ¥å›¾ç‰‡URLæ˜¯å¦æœ‰æ•ˆï¼Œå¦‚æœæ— æ•ˆåˆ™ä½¿ç”¨å ä½å›¾ç‰‡
    if (!imageUrl || imageUrl.includes('mock_')) {
        ElMessage.warning('è¯¥å›¾ç‰‡ä¸ºæ¨¡æ‹Ÿæ•°æ®ï¼Œå®é™…ç¯å¢ƒä¸­éœ€è¦é…ç½®çœŸå®çš„Google Driveå›¾ç‰‡é“¾æ¥');
        return;
    }
    
    const directUrl = convertToDirectUrl(imageUrl);
    currentImage.value = directUrl;
    imageDialogVisible.value = true;
 };
 
 const openImageInNewTab = () => {
    if (currentImage.value && !currentImage.value.includes('mock_')) {
        window.open(currentImage.value, '_blank');
    } else {
        ElMessage.warning('æ— æ³•æ‰“å¼€æ¨¡æ‹Ÿå›¾ç‰‡é“¾æ¥');
    }
 };
 
 // äº§å“ç®¡ç†
 const saveProduct = async () => {
  const code = productForm.value.code.trim().toUpperCase();
  if (!code || !code.match(/^[YC]*[ACDFGJMST0-9][A-Z0-9\-\/]*$/)) {
  ElMessage.error('äº§å“ä»£ç æ ¼å¼æ— æ•ˆï¼ˆä¾‹å¦‚ï¼šC6001ï¼‰');
  return;
  }
  
  if (catalogData.value[code] && editingProduct.value !== code) {
  try {
  await ElMessageBox.confirm('äº§å“ä»£ç å·²å­˜åœ¨ï¼Œæ˜¯å¦è¦†ç›–ï¼Ÿ', 'ç¡®è®¤', {
  type: 'warning'
  });
  } catch {
  return;
  }
  }
  
  saving.value = true;
  
  const newProduct = {
  code: code,
  price: productForm.value.price.trim() || '-',
  priceAlt: productForm.value.priceAlt.trim() || '-',
  width: productForm.value.width.trim() || '-',
  composition: productForm.value.composition.trim() || '-',
  weight: productForm.value.weight.trim() || '-',
  notes: productForm.value.notes.trim() || '-',
  supplier: productForm.value.supplier.trim() || '-'
  };
  
  catalogData.value[code] = newProduct;
  
  try {
  await saveData();
  ElMessage.success(editingProduct.value ? 'äº§å“å·²æ›´æ–°' : 'äº§å“å·²æ·»åŠ ');
  resetForm();
  } catch (error) {
  ElMessage.error('ä¿å­˜å¤±è´¥ï¼š' + error.message);
  }
  
  saving.value = false;
 };
 
 const editProduct = (code) => {
  if (!isDataLoaded.value) {
      ElMessage.warning('æ•°æ®æ­£åœ¨åŠ è½½ä¸­ï¼Œè¯·ç¨å€™å†è¯•ã€‚');
      return;
  }

  const product = catalogData.value[code];
  if (!product) {
       ElMessage.error('æ‰¾ä¸åˆ°è¯¥äº§å“æ•°æ®ï¼Œè¯·åˆ·æ–°åé‡è¯•ã€‚');
       return;
  }
  
  editingProduct.value = code;
  productForm.value = {
  code: product.code,
  price: product.price,
  priceAlt: product.priceAlt,
  width: product.width,
  composition: product.composition,
  weight: product.weight,
  notes: product.notes,
  supplier: product.supplier
  };
  
  activeTab.value = 'manage';
  
  nextTick(() => {
  window.scrollTo({ top: 0, behavior: 'smooth' });
  });
 };
 
 const deleteProduct = async () => {
  if (!editingProduct.value) return;
  
  try {
  await ElMessageBox.confirm('ç¡®å®šåˆ é™¤æ­¤äº§å“ï¼Ÿ', 'ç¡®è®¤åˆ é™¤', {
  type: 'warning'
  });
  
  await performDelete(editingProduct.value);

  ElMessage.success('äº§å“å·²åˆ é™¤');
  resetForm();
  } catch (error) {
     if (error !== 'cancel') {
         ElMessage.error('åˆ é™¤å¤±è´¥ï¼š' + (error.message || 'è¯·é‡è¯•'));
     }
  }
 };

 const performDelete = async (code) => {
  if (!isDataLoaded.value) {
      throw new Error('æ•°æ®æœªåŠ è½½å®Œæˆ');
  }
  
  delete catalogData.value[code];
  await saveData();
 }
 
 const confirmDelete = async (code) => {
  if (!isDataLoaded.value) {
      ElMessage.warning('æ•°æ®æ­£åœ¨åŠ è½½ä¸­ï¼Œè¯·ç¨å€™å†è¯•ã€‚');
      return;
  }

  try {
      await ElMessageBox.confirm(`ç¡®å®šåˆ é™¤äº§å“ ${code} å—ï¼Ÿ`, 'ç¡®è®¤åˆ é™¤', {
          type: 'warning'
      });
      
      await performDelete(code);
      
      ElMessage.success('äº§å“å·²åˆ é™¤');
      if (editingProduct.value === code) {
          resetForm();
      }
      
  } catch (error) {
      if (error === 'cancel' || error.message?.includes('cancel')) {
          return; 
      }
      console.error('Delete failed:', error);
      ElMessage.error('åˆ é™¤å¤±è´¥ï¼šæ“ä½œæœªæˆåŠŸä¿å­˜åˆ°æ•°æ®åº“ã€‚');
  }
 };
 
 const resetForm = () => {
  productForm.value = {
  code: '',
  price: '',
  priceAlt: '',
  width: '',
  composition: '',
  weight: '',
  notes: '',
  supplier: ''
  };
  editingProduct.value = null;
 };
 
 // æ™ºèƒ½å›¾ç‰‡æ˜ å°„åŠŸèƒ½
 const updateCloudConfig = async () => {
    await saveData();
    ElMessage.success('äº‘ç«¯é…ç½®å·²æ›´æ–°');
 };
 
 const testFolderConnection = async () => {
    if (!cloudConfig.value.folderUrl) {
        ElMessage.warning('è¯·è¾“å…¥Google Driveæ–‡ä»¶å¤¹é“¾æ¥');
        return;
    }
    
    try {
        // åˆ›å»ºä¸€ä¸ªæµ‹è¯•å›¾ç‰‡URLæ¥éªŒè¯è¿æ¥
        const testUrl = convertToDirectUrl(cloudConfig.value.folderUrl + '/test.jpg');
        const img = new Image();
        
        img.onload = () => {
            ElMessage.success('æ–‡ä»¶å¤¹è¿æ¥æµ‹è¯•æˆåŠŸï¼');
        };
        
        img.onerror = () => {
            ElMessage.warning('æ–‡ä»¶å¤¹è¿æ¥æµ‹è¯•å¤±è´¥ï¼Œä½†å¯èƒ½åªæ˜¯æµ‹è¯•å›¾ç‰‡ä¸å­˜åœ¨ã€‚å°†ç»§ç»­æ‰«æ...');
        };
        
        img.src = testUrl;
        
    } catch (error) {
        ElMessage.error('è¿æ¥æµ‹è¯•å¤±è´¥ï¼š' + error.message);
    }
 };
 
 const scanAndMapImages = async () => {
    if (!cloudConfig.value.folderUrl) {
        ElMessage.warning('è¯·å…ˆé…ç½®Google Driveæ–‡ä»¶å¤¹é“¾æ¥');
        return;
    }
    
    scanningImages.value = true;
    progressVisible.value = true;
    progressPercentage.value = 0;
    progressText.value = 'æ­£åœ¨æ‰«æGoogle Driveæ–‡ä»¶å¤¹...';
    progressStatus.value = '';
    
    try {
        // æ¨¡æ‹Ÿæ‰«æè¿‡ç¨‹ - åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œåº”è¯¥è°ƒç”¨Google Drive API
        // ç”±äºAPIé™åˆ¶ï¼Œæˆ‘ä»¬ä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®æ¥æ¼”ç¤ºåŠŸèƒ½
        
        const allProductCodes = Object.keys(catalogData.value);
        const foundImages = [];
        const mappedProducts = [];
        const unmatchedImages = [];
        
        progressPercentage.value = 30;
        progressText.value = 'æ­£åœ¨åŒ¹é…äº§å“ä»£ç å’Œå›¾ç‰‡...';
        
        // æ¨¡æ‹Ÿæ‰«æè¿‡ç¨‹
        for (let i = 0; i < allProductCodes.length; i++) {
            const code = allProductCodes[i];
            progressPercentage.value = 30 + Math.round((i / allProductCodes.length) * 50);
            progressText.value = `æ­£åœ¨å¤„ç†: ${code}`;
            
            // æ¨¡æ‹ŸæŸ¥æ‰¾åŒ¹é…çš„å›¾ç‰‡ - ä¿®å¤ï¼šä½¿ç”¨çœŸå®çš„å ä½å›¾ç‰‡URLè€Œä¸æ˜¯æ¨¡æ‹ŸID
            const matched = await findMatchingImage(code);
            if (matched) {
                foundImages.push({ code, url: matched });
                imageMapping.value[code] = matched;
                mappedProducts.push(code);
            }
            
            // æ·»åŠ å»¶è¿Ÿä»¥æ˜¾ç¤ºè¿›åº¦
            await new Promise(resolve => setTimeout(resolve, 50));
        }
        
        progressPercentage.value = 90;
        progressText.value = 'æ­£åœ¨ä¿å­˜æ˜ å°„ç»“æœ...';
        
        await saveData();
        
        progressPercentage.value = 100;
        progressStatus.value = 'success';
        progressText.value = 'å›¾ç‰‡æ˜ å°„å®Œæˆï¼';
        
        scanResults.value = {
            foundImages: foundImages.length,
            mappedProducts: mappedProducts.length,
            unmatchedImages: allProductCodes.length - mappedProducts.length
        };
        
        setTimeout(() => {
            progressVisible.value = false;
            scanningImages.value = false;
        }, 2000);
        
        ElNotification.success({
            title: 'å›¾ç‰‡æ˜ å°„å®Œæˆ',
            message: `æˆåŠŸæ˜ å°„ ${mappedProducts.length} ä¸ªäº§å“çš„å›¾ç‰‡`
        });
        
    } catch (error) {
        progressVisible.value = false;
        scanningImages.value = false;
        ElMessage.error('å›¾ç‰‡æ˜ å°„å¤±è´¥ï¼š' + error.message);
    }
 };
 
 const findMatchingImage = async (productCode) => {
    // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œåº”è¯¥è°ƒç”¨Google Drive APIæ¥æœç´¢æ–‡ä»¶
    // ç”±äºAPIé™åˆ¶ï¼Œæˆ‘ä»¬ä½¿ç”¨æ¨¡æ‹Ÿé€»è¾‘
    
    const extensions = cloudConfig.value.extensions;
    const baseUrl = cloudConfig.value.folderUrl;
    
    // æ¨¡æ‹ŸæŸ¥æ‰¾åŒ¹é…çš„å›¾ç‰‡æ–‡ä»¶
    for (const ext of extensions) {
        const possibleFilenames = [];
        
        if (cloudConfig.value.namingRule === 'exact') {
            possibleFilenames.push(`${productCode}.${ext}`);
            possibleFilenames.push(`${productCode}.${ext.toUpperCase()}`);
        } else {
            possibleFilenames.push(`${productCode}.${ext}`);
            possibleFilenames.push(`${productCode}.${ext.toUpperCase()}`);
            possibleFilenames.push(`${productCode}_1.${ext}`);
            possibleFilenames.push(`${productCode}_a.${ext}`);
        }
        
        for (const filename of possibleFilenames) {
            // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œåº”è¯¥æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
            // ç°åœ¨ä½¿ç”¨æ¨¡æ‹Ÿçš„æˆåŠŸç‡
            if (Math.random() > 0.7) { // 70%çš„æ¨¡æ‹ŸæˆåŠŸç‡
                // ä¿®å¤ï¼šä½¿ç”¨çœŸå®çš„å ä½å›¾ç‰‡URLè€Œä¸æ˜¯æ¨¡æ‹Ÿçš„Google Drive ID
                // è¿™æ ·å¯ä»¥é¿å…404é”™è¯¯
                const placeholderUrl = `https://via.placeholder.com/300x200/52D1B2/FFFFFF?text=${encodeURIComponent(productCode)}`;
                return placeholderUrl;
            }
        }
    }
    
    return null;
 };
 
 const clearImageMapping = async () => {
    try {
        await ElMessageBox.confirm('ç¡®å®šè¦æ¸…é™¤æ‰€æœ‰å›¾ç‰‡æ˜ å°„å—ï¼Ÿ', 'ç¡®è®¤æ¸…é™¤', {
            type: 'warning'
        });
        
        imageMapping.value = {};
        await saveData();
        scanResults.value = null;
        
        ElMessage.success('å›¾ç‰‡æ˜ å°„å·²æ¸…é™¤');
    } catch (error) {
        // ç”¨æˆ·å–æ¶ˆæ“ä½œ
    }
 };
 
 const exportImageMappingReport = () => {
    const rows = [
        ['äº§å“ä»£ç ', 'äº§å“åç§°', 'æ˜¯å¦æœ‰å›¾ç‰‡æ˜ å°„', 'å›¾ç‰‡URL']
    ];
    
    Object.values(catalogData.value).forEach(product => {
        const hasMapping = !!imageMapping.value[product.code];
        rows.push([
            product.code,
            product.supplier || '-',
            hasMapping ? 'æ˜¯' : 'å¦',
            hasMapping ? imageMapping.value[product.code] : '-'
        ]);
    });
    
    const wb = XLSX.utils.book_new();
    const ws = XLSX.utils.aoa_to_sheet(rows);
    XLSX.utils.book_append_sheet(wb, ws, 'å›¾ç‰‡æ˜ å°„æŠ¥å‘Š');
    
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    XLSX.writeFile(wb, `å›¾ç‰‡æ˜ å°„æŠ¥å‘Š_${timestamp}.xlsx`);
    
    ElNotification.success({
        title: 'å¯¼å‡ºæˆåŠŸ',
        message: 'å›¾ç‰‡æ˜ å°„æŠ¥å‘Šå·²ç”Ÿæˆ'
    });
 };
 
 // æ–‡ä»¶å¯¼å…¥ - ä¿®å¤ï¼šç¡®ä¿æ•°æ®æ ¼å¼æ­£ç¡®
 const parseSpreadsheetData = (rows) => {
  const data = {};
  if (rows.length < 2) return data;
  
  // ä¿®å¤ï¼šæ›´çµæ´»çš„è¡¨å¤´åŒ¹é…é€»è¾‘
  const normalizeHeader = (header) => {
      return String(header).trim().toUpperCase().replace(/[\s\W_]+/g, '');
  };
  
  const header = rows[0].map(h => normalizeHeader(h));
  const headerMap = {
      'äº§å“ä»£ç ': ['äº§å“ä»£ç ', 'CODE', 'ç¼–å·', 'è´§å·', 'äº§å“ç¼–å·', 'æ¬¾å·', 'å‹å·'],
      'ç ä»·': ['ç ä»·', 'ä»·æ ¼', 'PRICE', 'Mä»·', 'MCODE', 'ç ', 'å•ä»·'],
      'ç±³ä»·': ['ç±³ä»·', 'PRICEALT', 'Yä»·', 'YCODE', 'ç±³', 'ç±³ä»·å…ƒ'],
      'é—¨å¹…': ['é—¨å¹…', 'WIDTH', 'å¹…å®½', 'å¸ƒå°'],
      'æˆåˆ†': ['æˆåˆ†', 'COMPOSITION', 'çº±æ”¯', 'æè´¨', 'é¢æ–™æˆåˆ†'],
      'å…‹é‡': ['å…‹é‡', 'WEIGHT', 'KG', 'å…‹', 'é‡é‡', 'GSM'],
      'å¤‡æ³¨': ['å¤‡æ³¨', 'NOTES', 'è¯´æ˜', 'æè¿°'],
      'ä¾›åº”å•†': ['ä¾›åº”å•†', 'SUPPLIER', 'å‚å®¶', 'ç”Ÿäº§å•†', 'æ¥æº']
  };
  
  const columnIndex = {};
  Object.entries(headerMap).forEach(([key, aliases]) => {
      for (let alias of aliases) {
          const normalizedAlias = normalizeHeader(alias);
          const index = header.indexOf(normalizedAlias);
          if (index !== -1) {
              columnIndex[key] = index;
              break;
          }
      }
  });
  
  // å¦‚æœäº§å“ä»£ç åˆ—æœªæ‰¾åˆ°ï¼Œå°è¯•ä½¿ç”¨ç¬¬ä¸€åˆ—ä½œä¸ºäº§å“ä»£ç 
  if (columnIndex['äº§å“ä»£ç '] === undefined) {
      // å¦‚æœç¬¬ä¸€åˆ—çš„è¡¨å¤´æ˜¯ç©ºæˆ–è€…çœ‹èµ·æ¥åƒæ•°æ®ï¼Œæˆ‘ä»¬å‡è®¾ç¬¬ä¸€åˆ—æ˜¯äº§å“ä»£ç 
      if (header[0] && header[0].length > 0) {
          columnIndex['äº§å“ä»£ç '] = 0;
      } else {
          ElMessage.error('æ–‡ä»¶è§£æå¤±è´¥ï¼šæœªæ‰¾åˆ° "äº§å“ä»£ç " åˆ—');
          return {};
      }
  }
  
  let validCount = 0;
  for (let i = 1; i < rows.length; i++) {
  const row = rows[i];
  if (!row || !String(row[columnIndex['äº§å“ä»£ç ']]).trim()) continue;
  
  const code = String(row[columnIndex['äº§å“ä»£ç ']]).trim().toUpperCase();
  if (!code.match(/^[YC]*[ACDFGJMST0-9][A-Z0-9\-\/]*$/)) {
  continue;
  }
  
  data[code] = {
  code: code,
  price: String(row[columnIndex['ç ä»·']] || '-').trim(),
  priceAlt: String(row[columnIndex['ç±³ä»·']] || '-').trim(),
  width: String(row[columnIndex['é—¨å¹…']] || '-').trim(),
  composition: String(row[columnIndex['æˆåˆ†']] || '-').trim(),
  weight: String(row[columnIndex['å…‹é‡']] || '-').trim(),
  notes: String(row[columnIndex['å¤‡æ³¨']] || '-').trim(),
  supplier: String(row[columnIndex['ä¾›åº”å•†']] || '-').trim()
  };
  validCount++;
  }
  
  if (validCount === 0) {
      ElMessage.warning('æ–‡ä»¶å¤„ç†å®Œæˆï¼Œä½†æœªæ‰¾åˆ°æœ‰æ•ˆæ•°æ®ã€‚è¯·æ£€æŸ¥äº§å“ä»£ç æ ¼å¼ï¼ˆä¾‹å¦‚ï¼šC6001ï¼‰');
  }
  
  return data;
 };
 
 // ä¿®å¤ï¼šä¼˜åŒ–è¿›åº¦æç¤ºæ¡†å…³é—­é€»è¾‘
 const handleFileUpload = async (file, fileList) => {
  progressVisible.value = true;
  progressPercentage.value = 0;
  progressText.value = 'æ­£åœ¨å¤„ç†æ–‡ä»¶...';
  progressStatus.value = '';
  
  const processedFiles = [];
  
  try {
      for (let i = 0; i < fileList.length; i++) {
      const f = fileList[i];
      progressPercentage.value = Math.round((i / fileList.length) * 100);
      progressText.value = `æ­£åœ¨å¤„ç†: ${f.name}`;
  
      const fileType = f.name.toLowerCase().endsWith('.csv') ? 'csv' : 'xlsx';
      const reader = new FileReader();
  
      const result = await new Promise((resolve, reject) => {
      reader.onload = (e) => resolve(e.target.result);
      reader.onerror = reject;
  
      if (fileType === 'csv') {
      reader.readAsText(f.raw);
      } else {
      reader.readAsArrayBuffer(f.raw);
      }
      });
  
      let rows;
      if (fileType === 'csv') {
      const results = Papa.parse(result, { skipEmptyLines: true });
      rows = results.data;
      } else {
      const data = new Uint8Array(result);
      const workbook = XLSX.read(data, { type: 'array' });
      const sheetName = workbook.SheetNames[0];
      rows = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName], { header: 1 });
      }
  
      const newData = parseSpreadsheetData(rows);
      
      // ä¿®å¤ï¼šç¡®ä¿æ–°æ•°æ®æ˜¯æ™®é€šå¯¹è±¡è€Œä¸æ˜¯å“åº”å¼å¯¹è±¡
      const plainNewData = JSON.parse(JSON.stringify(newData));
      Object.assign(catalogData.value, plainNewData);
  
      processedFiles.push({
      name: f.name,
      uploadTime: new Date().toLocaleString('zh-CN'),
      count: Object.keys(newData).length
      });
      }
  
      processedFiles.forEach(pf => {
      uploadedFiles.value = uploadedFiles.value.filter(f => f.name !== pf.name);
      uploadedFiles.value.push(pf);
      });
  
      progressPercentage.value = 100;
      progressStatus.value = 'success';
      progressText.value = `å¯¼å…¥å®Œæˆï¼`;
  
      await saveData();
      
      // ä¿®å¤ï¼šç¡®ä¿è¿›åº¦æç¤ºæ¡†æ­£ç¡®å…³é—­
      setTimeout(() => {
          progressVisible.value = false;
      }, 800);
  
      ElNotification.success({
      title: 'å¯¼å…¥æˆåŠŸ',
      message: `å·²å¯¼å…¥ ${processedFiles.length} ä¸ªæ–‡ä»¶ï¼Œå…± ${Object.keys(catalogData.value).length} æ¡äº§å“æ•°æ®`
      });
  } catch (error) {
      console.error('File processing error:', error);
      progressVisible.value = false;
      ElMessage.error(`æ–‡ä»¶å¤„ç†å¤±è´¥: ${error.message}`);
  }
 };
 
 // ä¿®å¤ï¼šä¼˜åŒ–æ•°æ®åº“å¯¼å…¥çš„è¿›åº¦æç¤ºæ¡†å…³é—­é€»è¾‘
 const handleDatabaseImport = async (file) => {
  progressVisible.value = true;
  progressPercentage.value = 0;
  progressText.value = 'æ­£åœ¨å¯¼å…¥æ•°æ®åº“...';
  progressStatus.value = '';
  
  try {
      if (file.name.endsWith('.json')) {
          const reader = new FileReader();
          const result = await new Promise((resolve, reject) => {
              reader.onload = (e) => resolve(e.target.result);
              reader.onerror = reject;
              reader.readAsText(file.raw);
          });
          
          progressPercentage.value = 50;
          
          const data = JSON.parse(result);
          let loadedCatalogData = data.catalogData || data;
          
          // ä¿®å¤ï¼šç¡®ä¿æ•°æ®æ ¼å¼æ­£ç¡®
          if (Array.isArray(loadedCatalogData)) {
              const arrayToObject = {};
              loadedCatalogData.forEach(item => {
                  if (item && item.code) {
                      arrayToObject[item.code] = item;
                  }
              });
              loadedCatalogData = arrayToObject;
          }
          
          const finalCatalogData = {};
          Object.keys(loadedCatalogData).forEach(code => {
              if (loadedCatalogData[code] && loadedCatalogData[code].code) {
                  finalCatalogData[code] = { ...loadedCatalogData[code], code };
              }
          });
          
          // ä¿®å¤ï¼šç¡®ä¿æ•°æ®æ˜¯æ™®é€šå¯¹è±¡
          catalogData.value = JSON.parse(JSON.stringify(finalCatalogData));

          if (data.imageMapping) {
              imageMapping.value = data.imageMapping;
          }

          uploadedFiles.value = data.uploadedFiles || [];
          searchHistory.value = data.searchHistory || [];
          
          progressPercentage.value = 100;
          progressStatus.value = 'success';
          progressText.value = 'æ•°æ®åº“å¯¼å…¥æˆåŠŸï¼';
          
          await saveData();
          
          // ä¿®å¤ï¼šç¡®ä¿è¿›åº¦æç¤ºæ¡†æ­£ç¡®å…³é—­
          setTimeout(() => {
              progressVisible.value = false;
          }, 800);
          
          ElNotification.success({
              title: 'å¯¼å…¥æˆåŠŸ',
              message: 'æ•°æ®åº“å·²æˆåŠŸå¯¼å…¥'
          });
      } else if (file.name.endsWith('.zip')) {
          const reader = new FileReader();
          const result = await new Promise((resolve, reject) => {
              reader.onload = (e) => resolve(e.target.result);
              reader.onerror = reject;
              reader.readAsArrayBuffer(file.raw);
          });
          
          progressPercentage.value = 30;
          progressText.value = 'æ­£åœ¨è§£å‹ZIPæ–‡ä»¶...';
          
          const zip = await JSZip.loadAsync(result);
          const jsonFile = zip.file('database.json');
          
          if (!jsonFile) {
              throw new Error('ZIPæ–‡ä»¶ä¸­æœªæ‰¾åˆ° database.json');
          }
          
          progressPercentage.value = 50;
          progressText.value = 'æ­£åœ¨è¯»å–æ•°æ®...';
          
          const content = await jsonFile.async('string');
          const data = JSON.parse(content);
          let loadedCatalogData = data.catalogData;
          
          // ä¿®å¤ï¼šç¡®ä¿æ•°æ®æ ¼å¼æ­£ç¡®
          if (Array.isArray(loadedCatalogData)) {
              const arrayToObject = {};
              loadedCatalogData.forEach(item => {
                  if (item && item.code) {
                      arrayToObject[item.code] = item;
                  }
              });
              loadedCatalogData = arrayToObject;
          }
          
          const finalCatalogData = {};
          Object.keys(loadedCatalogData).forEach(code => {
              if (loadedCatalogData[code] && loadedCatalogData[code].code) {
                  finalCatalogData[code] = { ...loadedCatalogData[code], code };
              }
          });
          
          // ä¿®å¤ï¼šç¡®ä¿æ•°æ®æ˜¯æ™®é€šå¯¹è±¡
          catalogData.value = JSON.parse(JSON.stringify(finalCatalogData));

          if (data.imageMapping) {
              imageMapping.value = data.imageMapping;
          }

          uploadedFiles.value = data.uploadedFiles || [];
          searchHistory.value = data.searchHistory || [];
          
          progressPercentage.value = 100;
          progressStatus.value = 'success';
          progressText.value = 'å®Œæ•´æ•°æ®åº“å¯¼å…¥æˆåŠŸï¼';
          
          await saveData();
          
          // ä¿®å¤ï¼šç¡®ä¿è¿›åº¦æç¤ºæ¡†æ­£ç¡®å…³é—­
          setTimeout(() => {
              progressVisible.value = false;
          }, 800);
          
          ElNotification.success({
              title: 'å¯¼å…¥æˆåŠŸ',
              message: 'å®Œæ•´æ•°æ®åº“å·²æˆåŠŸå¯¼å…¥'
          });
      } else {
          throw new Error('ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼');
      }
  } catch (error) {
      progressVisible.value = false;
      ElMessage.error('å¯¼å…¥å¤±è´¥ï¼š' + error.message);
  }
 };
 
 // æ•°æ®å¯¼å‡º
 const exportAllData = async () => {
  if (Object.keys(catalogData.value).length === 0) {
  ElMessage.error('æ— æ•°æ®å¯å¯¼å‡º');
  return;
  }
  
  progressVisible.value = true;
  progressPercentage.value = 0;
  progressText.value = 'æ­£åœ¨ç”Ÿæˆå®Œæ•´å¤‡ä»½...';
  progressStatus.value = '';
  
  try {
  const zip = new JSZip();
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  
  progressPercentage.value = 20;
  progressText.value = 'æ­£åœ¨æ‰“åŒ…æ•°æ®...';
  
  // ä¿®å¤ï¼šç¡®ä¿å¯¼å‡ºçš„æ•°æ®æ˜¯å¯åºåˆ—åŒ–çš„
  const dbData = {
  catalogData: JSON.parse(JSON.stringify(catalogData.value)),
  uploadedFiles: uploadedFiles.value,
  searchHistory: searchHistory.value,
  cloudConfig: cloudConfig.value,
  imageMapping: imageMapping.value,
  exportTime: timestamp
  };
  zip.file('database.json', JSON.stringify(dbData, null, 2));
  
  progressPercentage.value = 60;
  progressText.value = 'æ­£åœ¨ç”ŸæˆExcelè¡¨æ ¼...';
  
  const rows = [
  ['äº§å“ä»£ç ', 'ç ä»·', 'ç±³ä»·', 'é—¨å¹…', 'æˆåˆ†', 'å…‹é‡', 'å¤‡æ³¨', 'ä¾›åº”å•†']
  ];
  Object.entries(catalogData.value).forEach(([code, p]) => {
  rows.push([
  p.code || code,
  p.price || '-',
  p.priceAlt || '-',
  p.width || '-',
  p.composition || '-',
  p.weight || '-',
  p.notes || '-',
  p.supplier || '-'
  ]);
  });
  
  const wb = XLSX.utils.book_new();
  const ws = XLSX.utils.aoa_to_sheet(rows);
  XLSX.utils.book_append_sheet(wb, ws, 'äº§å“æ•°æ®');
  const xlsxBuffer = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });
  zip.file('äº§å“æ•°æ®è¡¨.xlsx', xlsxBuffer);
  
  progressPercentage.value = 80;
  progressText.value = 'æ­£åœ¨ç”ŸæˆZIPæ–‡ä»¶...';
  
  const content = await zip.generateAsync({
  type: 'blob',
  compression: 'DEFLATE',
  compressionOptions: { level: 6 }
  });
  
  progressPercentage.value = 100;
  progressStatus.value = 'success';
  progressText.value = 'å¯¼å‡ºå®Œæˆï¼';
  
  const link = document.createElement('a');
  link.href = URL.createObjectURL(content);
  link.download = `å®‡ä¸œçººç»‡å…¨åº“å¤‡ä»½_${timestamp}.zip`;
  link.click();
  URL.revokeObjectURL(link.href);
  
  setTimeout(() => {
  progressVisible.value = false;
  }, 2000);
  
  ElNotification.success({
  title: 'å¯¼å‡ºæˆåŠŸ',
  message: 'å®Œæ•´å¤‡ä»½å·²ç”Ÿæˆ'
  });
  } catch (error) {
  progressVisible.value = false;
  ElMessage.error('å¯¼å‡ºå¤±è´¥ï¼š' + error.message);
  }
 };
 
 // PDFå¯¼å‡º - ä½¿ç”¨html2canvasæ–¹æ¡ˆé¿å…ä¸­æ–‡ä¹±ç 
 const exportQuotePDF = async () => {
    progressVisible.value = true;
    progressPercentage.value = 0;
    progressText.value = 'æ­£åœ¨æ”¶é›†æ•°æ®...';
    progressStatus.value = '';
    
    const pdfContent = document.getElementById('pdf-content');
    
    try {
        const allResults = [];
        searchResults.value.filter(r => r.found !== false).forEach(r => allResults.push(r));
        rangeResults.value.forEach(r => {
            r.matches.forEach(m => allResults.push(m));
        });
        
        const uniqueResults = {};
        allResults.forEach(r => {
            uniqueResults[r.code] = r;
        });
        const results = Object.values(uniqueResults).sort((a, b) => a.code.localeCompare(b.code));
        
        if (results.length === 0) {
            progressVisible.value = false;
            ElMessage.error('æ— ç»“æœå¯å¯¼å‡º');
            return;
        }

        progressPercentage.value = 20;
        progressText.value = 'æ­£åœ¨åˆ›å»ºHTMLæŠ¥ä»·å•ç»“æ„...';

        // 1. HTMLå†…å®¹ç”Ÿæˆ
        const now = new Date();
        const dateString = now.toLocaleDateString('zh-CN', { year: 'numeric', month: '2-digit', day: '2-digit' }).replace(/\//g, '');
        const timeString = now.toLocaleTimeString('zh-CN', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
        const dateTimeFormatted = `${now.getFullYear()}/${(now.getMonth() + 1).toString().padStart(2, '0')}/${now.getDate().toString().padStart(2, '0')} ${timeString}`;
        const fileNameTime = `${now.getFullYear()}${(now.getMonth() + 1).toString().padStart(2, '0')}${now.getDate().toString().padStart(2, '0')}_${now.getHours().toString().padStart(2, '0')}${now.getMinutes().toString().padStart(2, '0')}${now.getSeconds().toString().padStart(2, '0')}`;

        let tableBodyHtml = '';
        results.forEach((p, index) => {
            const notesContent = (p.notes && p.notes !== '-') ? p.notes : '';

            // æ³¨æ„ï¼šä¾›åº”å•†åˆ—å·²ç§»é™¤ï¼Œåªæ˜¾ç¤º7åˆ—
            tableBodyHtml += `
                <tr>
                    <td style="width: 8%;">${index + 1}</td>
                    <td style="width: 15%; font-weight: bold;">${p.code}</td>
                    <td style="width: 12%;">${p.price}</td>
                    <td style="width: 12%;">${p.priceAlt}</td>
                    <td style="width: 10%;">${p.width}</td>
                    <td style="width: 28%;">${p.composition}</td>
                    <td style="width: 10%;">${p.weight}</td>
                    <td style="width: 15%;" class="notes-cell">${notesContent}</td>
                </tr>
            `;
        });

        const pdfContentHtml = `
            <div id="pdf-container">
                <div style="text-align: center; margin-bottom: 5mm;">
                    <h1 style="color: #007AFF; font-size: 16pt; margin: 0; padding-bottom: 2px;">
                        ğŸ­ å®‡ä¸œçººç»‡æŠ¥ä»·å•
                    </h1>
                    <div style="border-bottom: 2px solid #007AFF; width: 30%; margin: 0 auto 5px auto;"></div>
                    <p style="font-size: 8pt; color: #666; margin: 0;">
                        ç”Ÿæˆæ—¶é—´: ${dateTimeFormatted} | äº§å“æ•°é‡: ${results.length}
                    </p>
                </div>

                <table>
                    <thead>
                        <tr>
                            <th style="width: 8%;">åºå·</th>
                            <th style="width: 15%;">äº§å“ä»£ç </th>
                            <th style="width: 12%;">ç ä»·</th>
                            <th style="width: 12%;">ç±³ä»·</th>
                            <th style="width: 10%;">é—¨å¹…</th>
                            <th style="width: 28%;">æˆåˆ†</th>
                            <th style="width: 10%;">å…‹é‡</th>
                            <th style="width: 15%;">å¤‡æ³¨</th>
                            <!-- ä¾›åº”å•†å·²ç§»é™¤ -->
                        </tr>
                    </thead>
                    <tbody>
                        ${tableBodyHtml}
                    </tbody>
                </table>
                
                <!-- é¡µè„š -->
                <div style="text-align: center; margin-top: 10mm; font-size: 6pt; color: #999;">
                    æœ¬æŠ¥ä»·å•ç”±å®‡ä¸œçººç»‡æŠ¥ä»·ç³»ç»Ÿç”Ÿæˆ | ç³»ç»Ÿç‰ˆæœ¬ï¼šv4.1æ™ºèƒ½äº‘ç«¯ç‰ˆ
                </div>
            </div>
        `;

        // 2. å°†å†…å®¹æ³¨å…¥éšè—å®¹å™¨
        if (!pdfContent) {
            throw new Error('PDF content container not found.');
        }
        pdfContent.innerHTML = pdfContentHtml;

        progressPercentage.value = 50;
        progressText.value = 'æ­£åœ¨å°†HTMLæ¸²æŸ“ä¸ºé«˜æ¸…å›¾åƒ...';
        
        // å…³é”®æ­¥éª¤: ç¡®ä¿å…ƒç´ å¯è§
        pdfContent.style.display = 'block';

        // 3. ç”ŸæˆCanvas (ä½¿ç”¨ html2canvas)
        const canvas = await html2canvas(pdfContent, {
            scale: 2, // 2å€åˆ†è¾¨ç‡
            useCORS: true,
            allowTaint: true,
            backgroundColor: '#ffffff'
        });
        
        // å…³é”®å®‰å…¨æ£€æŸ¥
        if (!canvas.width || !canvas.height) {
            throw new Error(`Canvaså°ºå¯¸æ— æ•ˆ: å®½åº¦=${canvas.width}, é«˜åº¦=${canvas.height}`);
        }

        // æ¸²æŸ“å®Œæˆåç«‹å³éšè—
        pdfContent.style.display = 'none';

        // æ”¹ç”¨ JPEG æ ¼å¼ï¼Œæé«˜ç¨³å®šæ€§
        const imgData = canvas.toDataURL('image/jpeg', 0.9); // 0.9 è´¨é‡çš„ JPEG
        
        // 4. ç”ŸæˆPDFå¹¶ä¸‹è½½ (ä½¿ç”¨ jsPDF)
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF('l', 'mm', 'a4'); 
        
        // A4 å°ºå¯¸ (å•ä½: mm)
        const PDF_WIDTH = doc.internal.pageSize.getWidth(); // 297mm
        const PDF_HEIGHT = doc.internal.pageSize.getHeight(); // 210mm
        
        // è¾¹è· (mm)
        const margin = 10; 
        const contentWidth = PDF_WIDTH - (2 * margin); // 277mm
        
        // å›¾åƒå°ºå¯¸ï¼ˆå•ä½ï¼šmmï¼‰
        const canvasWidth = canvas.width;
        const canvasHeight = canvas.height;
        
        const imgWidth = contentWidth; // å›¾åƒå®½åº¦ç­‰äºå†…å®¹å®½åº¦
        const imgHeight = (canvasHeight * imgWidth) / canvasWidth; // ä¿æŒæ¯”ä¾‹è®¡ç®—é«˜åº¦

        let heightLeft = imgHeight;

        progressPercentage.value = 70;
        progressText.value = 'æ­£åœ¨å°†å›¾åƒè½¬æ¢åˆ°PDFå¤šé¡µ...';

        let pageIndex = 0; // ä»ç¬¬0é¡µå¼€å§‹ï¼ˆç¬¬ä¸€é¡µï¼‰
        
        while (heightLeft > -10) { // å®¹é”™èŒƒå›´ -10
            pageIndex++;
            
            // å¦‚æœä¸æ˜¯ç¬¬ä¸€é¡µï¼Œåˆ™æ·»åŠ æ–°é¡µ
            if (pageIndex > 1) {
                doc.addPage();
            }

            // è®¡ç®—å›¾åƒåœ¨å½“å‰é¡µé¢ä¸Šçš„èµ·å§‹ Y åæ ‡ (è´Ÿå€¼)
            const effectivePageHeight = PDF_HEIGHT - margin; 
            const yPosition = margin - ((pageIndex - 1) * effectivePageHeight); 

            doc.addImage(imgData, 'JPEG', margin, yPosition, imgWidth, imgHeight);
            
            heightLeft -= effectivePageHeight; 
        }

        progressPercentage.value = 90;
        progressStatus.value = 'success';
        progressText.value = 'PDFç”ŸæˆæˆåŠŸï¼æ­£åœ¨ä¸‹è½½...';

        // 5. æ¸…ç†å¹¶ä¸‹è½½
        pdfContent.innerHTML = ''; // æ¸…ç†éšè—å®¹å™¨
        pdfContent.style.display = 'none';
        
        // ç”Ÿæˆæ–‡ä»¶å
        const downloadFileName = `å®‡ä¸œçººç»‡æŠ¥ä»·å•_${dateString}_${fileNameTime}.pdf`;
        doc.save(downloadFileName);
        
        setTimeout(() => {
            progressVisible.value = false;
        }, 2000);
        
        ElNotification.success({
            title: 'PDFå¯¼å‡ºæˆåŠŸ',
            message: 'æŠ¥ä»·å•å·²ç”Ÿæˆå¹¶ä¸‹è½½'
        });
        
    } catch (error) {
        pdfContent.innerHTML = ''; 
        pdfContent.style.display = 'none';
        progressVisible.value = false;
        console.error('PDFç”Ÿæˆå¤±è´¥:', error);
        
        const errorMessage = error.message.includes('Canvaså°ºå¯¸æ— æ•ˆ') 
            ? 'Canvaså°ºå¯¸æ— æ•ˆ (è¯·æ£€æŸ¥CSSéšè—æ–¹å¼)'
            : (error.message || 'æœªçŸ¥é”™è¯¯');
            
        ElMessage.error('PDFç”Ÿæˆå¤±è´¥ï¼šæ•°æ®æˆ–å›¾åƒå¤„ç†å¼‚å¸¸ã€‚è¯¦ç»†ä¿¡æ¯: ' + errorMessage);
    }
 };
 
 // äº‘ç«¯å­˜å‚¨åŠŸèƒ½
 const uploadToGoogleDrive = async () => {
    cloudUploading.value = true;
    cloudStatus.value = 'syncing';
    cloudStatusText.value = 'æ­£åœ¨å¤‡ä»½åˆ°äº‘ç«¯...';
    
    try {
        const backupData = {
            catalogData: JSON.parse(JSON.stringify(catalogData.value)),
            uploadedFiles: uploadedFiles.value,
            searchHistory: searchHistory.value,
            cloudConfig: cloudConfig.value,
            imageMapping: imageMapping.value,
            backupTime: new Date().toISOString()
        };
        
        const blob = new Blob([JSON.stringify(backupData, null, 2)], { 
            type: 'application/json' 
        });
        
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const fileName = `å®‡ä¸œçººç»‡äº‘ç«¯å¤‡ä»½_${timestamp}.json`;
        
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = fileName;
        link.click();
        URL.revokeObjectURL(url);
        
        const backupRecord = {
            name: fileName,
            timestamp: new Date().toLocaleString('zh-CN'),
            productCount: Object.keys(catalogData.value).length,
            size: (blob.size / 1024).toFixed(2) + ' KB'
        };
        
        cloudBackups.value.push(backupRecord);
        localStorage.setItem('cloud-backups', JSON.stringify(cloudBackups.value));
        
        cloudStatus.value = 'connected';
        cloudStatusText.value = 'äº‘ç«¯å¤‡ä»½å®Œæˆ';
        cloudUploading.value = false;
        
        ElNotification.success({
            title: 'äº‘ç«¯å¤‡ä»½æˆåŠŸ',
            message: 'æ•°æ®å·²å¤‡ä»½åˆ°æœ¬åœ°æ–‡ä»¶ï¼Œè¯·æ‰‹åŠ¨ä¸Šä¼ åˆ°Google Drive'
        });
        
    } catch (error) {
        cloudStatus.value = 'disconnected';
        cloudStatusText.value = 'äº‘ç«¯å¤‡ä»½å¤±è´¥';
        cloudUploading.value = false;
        ElMessage.error('äº‘ç«¯å¤‡ä»½å¤±è´¥ï¼š' + error.message);
    }
 };
 
 const downloadFromGoogleDrive = async () => {
    cloudDownloading.value = true;
    cloudStatus.value = 'syncing';
    cloudStatusText.value = 'æ­£åœ¨ä»äº‘ç«¯æ¢å¤...';
    
    try {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) {
                cloudDownloading.value = false;
                cloudStatus.value = 'disconnected';
                cloudStatusText.value = 'æœªé€‰æ‹©æ–‡ä»¶';
                return;
            }
            
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    if (data.catalogData) {
                        catalogData.value = data.catalogData;
                    }
                    if (data.uploadedFiles) {
                        uploadedFiles.value = data.uploadedFiles;
                    }
                    if (data.searchHistory) {
                        searchHistory.value = data.searchHistory;
                    }
                    if (data.cloudConfig) {
                        Object.assign(cloudConfig.value, data.cloudConfig);
                    }
                    if (data.imageMapping) {
                        imageMapping.value = data.imageMapping;
                    }
                    
                    await saveData();
                    
                    cloudStatus.value = 'connected';
                    cloudStatusText.value = 'äº‘ç«¯æ¢å¤å®Œæˆ';
                    cloudDownloading.value = false;
                    
                    ElNotification.success({
                        title: 'äº‘ç«¯æ¢å¤æˆåŠŸ',
                        message: 'æ•°æ®å·²ä»å¤‡ä»½æ–‡ä»¶æ¢å¤'
                    });
                    
                } catch (parseError) {
                    cloudStatus.value = 'disconnected';
                    cloudStatusText.value = 'æ–‡ä»¶æ ¼å¼é”™è¯¯';
                    cloudDownloading.value = false;
                    ElMessage.error('æ–‡ä»¶è§£æå¤±è´¥ï¼š' + parseError.message);
                }
            };
            reader.readAsText(file);
        };
        input.click();
        
    } catch (error) {
        cloudStatus.value = 'disconnected';
        cloudStatusText.value = 'äº‘ç«¯æ¢å¤å¤±è´¥';
        cloudDownloading.value = false;
        ElMessage.error('äº‘ç«¯æ¢å¤å¤±è´¥ï¼š' + error.message);
    }
 };
 
 // åˆå§‹åŒ–äº‘ç«¯çŠ¶æ€
 const initCloudStatus = () => {
    const savedBackups = localStorage.getItem('cloud-backups');
    if (savedBackups) {
        cloudBackups.value = JSON.parse(savedBackups);
    }
    
    cloudStatus.value = 'connected';
    cloudStatusText.value = 'æ™ºèƒ½äº‘ç«¯å­˜å‚¨å·²å°±ç»ª';
 };
 
 // æ¸…ç©ºæ•°æ®
 const clearAllData = async () => {
  try {
  await ElMessageBox.confirm(
  'è­¦å‘Šï¼šæ­¤æ“ä½œå°†æ¸…ç©ºæ‰€æœ‰äº§å“æ•°æ®ã€æ–‡ä»¶ä¿¡æ¯å’Œæœç´¢å†å²ï¼Œä¸”ä¸å¯é€†ï¼',
  'ç¡®è®¤æ¸…ç©º',
  {
  type: 'error',
  confirmButtonText: 'ç¡®å®šæ¸…ç©º',
  cancelButtonText: 'å–æ¶ˆ'
  }
  );
  
  catalogData.value = {};
  uploadedFiles.value = [];
  searchHistory.value = [];
  searchResults.value = [];
  fuzzyMatches.value = [];
  rangeResults.value = [];
  imageMapping.value = {};
  
  localStorage.clear();
  indexedDB.deleteDatabase(DB_NAME);
  db = null;
  
  ElNotification.success({
  title: 'æ¸…ç©ºå®Œæˆ',
  message: 'æ‰€æœ‰æ•°æ®å·²æ¸…ç©º'
  });
  } catch {}
 };
 
 // ç›‘å¬çª—å£å¤§å°å˜åŒ–
 const handleResize = () => {
  isMobile.value = window.innerWidth < 768;
 };
 
 onMounted(async () => {
  await loadData();
  initCloudStatus();
  window.addEventListener('resize', handleResize);
  
  // å°†getProductImageUrlæ–¹æ³•æŒ‚è½½åˆ°windowï¼Œä¾›ProductCardç»„ä»¶ä½¿ç”¨
  window.getProductImageUrl = getProductImageUrl;
  
  document.addEventListener('click', (e) => {
  if (!e.target.closest('.search-input-wrapper')) {
  showAutocomplete.value = false;
  }
  });
 });
 
 return {
  activeTab,
  catalogData,
  uploadedFiles,
  searchHistory,
  searchInput,
  searchResults,
  fuzzyMatches,
  rangeResults,
  searching,
  manageSearchTerm,
  currentPage,
  pageSize,
  listKey, 
  isDataLoaded,
  productForm,
  editingProduct,
  saving,
  imageDialogVisible,
  currentImage,
  progressVisible,
  progressPercentage,
  progressStatus,
  progressText,
  showAutocomplete,
  autocompleteItems,
  isMobile,
  totalResults,
  filteredProducts,
  paginatedProducts,
  cloudStatus,
  cloudStatusText,
  cloudUploading,
  cloudDownloading,
  cloudBackups,
  cloudConfig,
  imageMapping,
  scanningImages,
  scanResults,
  mappedProductCount,
  totalProductCount,
  coverageRate,
  recentMappedImages,
  handleSearchInput,
  selectAutocomplete,
  performSearch,
  selectFuzzyMatch,
  scrollToProduct,
  loadHistory,
  clearSearch,
  clearSearchHistory,
  getProductImageUrl,
  viewImage,
  openImageInNewTab,
  saveProduct,
  editProduct,
  deleteProduct,
  confirmDelete,
  resetForm,
  updateCloudConfig,
  testFolderConnection,
  scanAndMapImages,
  clearImageMapping,
  exportImageMappingReport,
  handleFileUpload,
  handleDatabaseImport,
  exportAllData,
  exportQuotePDF,
  uploadToGoogleDrive,
  downloadFromGoogleDrive,
  clearAllData
 };
 }
 });

 // æ³¨å†Œ Element Plus Icons
 for (const [key, component] of Object.entries(ElementPlusIconsVue)) {
 app.component(key, component);
 }

 app.use(ElementPlus);
 app.mount('#app');
 </script>
</body>
</html>